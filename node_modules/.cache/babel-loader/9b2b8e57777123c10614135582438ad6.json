{"ast":null,"code":"import _extends from '@babel/runtime/helpers/extends';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport axios from 'axios';\nimport uuidv4 from 'uuid/v4';\nimport Immutable from 'seamless-immutable';\nimport isoWS from 'isomorphic-ws';\nimport fetch, { Headers } from 'cross-fetch';\nimport FormData from 'form-data';\n/**\n * ChannelState - A container class for the channel state.\n */\n\nfunction byDate(a, b) {\n  return a.created_at - b.created_at;\n}\n\nvar ChannelState =\n/*#__PURE__*/\nfunction () {\n  function ChannelState(channel) {\n    _classCallCheck(this, ChannelState);\n\n    this._channel = channel;\n    this.watcher_count = 0;\n    this.typing = Immutable({});\n    this.read = Immutable({});\n    this.messages = Immutable([]);\n    this.threads = Immutable({}); // a list of users to hide messages from\n\n    this.mutedUsers = Immutable([]);\n    this.watchers = Immutable({});\n    this.members = Immutable({});\n  }\n  /**\n   * addMessageSorted - Add a message to the state\n   *\n   * @param {object} newMessage A new message\n   *\n   */\n\n\n  _createClass(ChannelState, [{\n    key: \"addMessageSorted\",\n    value: function addMessageSorted(newMessage) {\n      return this.addMessagesSorted([newMessage]);\n    }\n    /**\n     * messageToImmutable - Takes the message object. Parses the dates, sets __html\n     * and sets the status to received if missing. Returns an immutable message object\n     *\n     * @param {object} message an Immutable message object\n     *\n     */\n\n  }, {\n    key: \"messageToImmutable\",\n    value: function messageToImmutable(message) {\n      message.__html = message.html; // parse the date..\n\n      message.created_at = new Date(message.created_at);\n      message.updated_at = new Date(message.updated_at);\n\n      if (!message.status) {\n        message.status = 'received';\n      }\n\n      return Immutable(message);\n    }\n    /**\n     * addMessagesSorted - Add the list of messages to state and resorts the messages\n     *\n     * @param {array} newMessages A list of messages\n     *\n     */\n\n  }, {\n    key: \"addMessagesSorted\",\n    value: function addMessagesSorted(newMessages) {\n      // parse all the new message dates and add __html for react\n      var parsedMessages = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var message = _step.value;\n          parsedMessages.push(this.messageToImmutable(message));\n        } // update or append the messages...\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var updatedThreads = [];\n\n      for (var _i = 0; _i < parsedMessages.length; _i++) {\n        var _message = parsedMessages[_i];\n        var isThreadReply = _message.parent_id && !_message.show_in_channel; // add to the main message list\n\n        if (!isThreadReply) {\n          this.messages = this._addToMessageList(this.messages, _message);\n        } // add to the thread if applicable..\n\n\n        var parentID = _message.parent_id;\n\n        if (parentID) {\n          var thread = this.threads[parentID] || Immutable([]);\n\n          var threadMessages = this._addToMessageList(thread, _message);\n\n          this.threads = this.threads.set(parentID, threadMessages);\n          updatedThreads.push(parentID);\n        }\n      } // Resort the main messages and the threads that changed...\n\n\n      var messages = _toConsumableArray(this.messages);\n\n      messages.sort(byDate);\n      this.messages = Immutable(messages);\n\n      for (var _i2 = 0; _i2 < updatedThreads.length; _i2++) {\n        var _parentID = updatedThreads[_i2];\n\n        var _threadMessages = this.threads[_parentID] ? _toConsumableArray(this.threads[_parentID]) : [];\n\n        _threadMessages.sort(byDate);\n\n        this.threads = this.threads.set(_parentID, _threadMessages);\n      }\n    }\n    /**\n     * _addToMessageList - Adds a message to a list of messages, tries to update first, appends if message isnt found\n     *\n     * @param {array} messages A list of messages\n     * @param {object} newMessage The new message\n     *\n     */\n\n  }, {\n    key: \"_addToMessageList\",\n    value: function _addToMessageList(messages, newMessage) {\n      var updated = false;\n\n      for (var i = 0; i < messages.length; i++) {\n        var message = messages[i];\n        var idMatch = message.id && newMessage.id && message.id === newMessage.id;\n\n        if (idMatch) {\n          messages = messages.set(i, newMessage);\n          updated = true;\n        }\n      }\n\n      if (!updated) {\n        messages = messages.concat([newMessage]);\n      }\n\n      return messages;\n    }\n    /**\n     * removeMessage - Description\n     *\n     * @param {type} messageToRemove Object of the message to remove. Needs to have at id specified.\n     *\n     * @return {boolean} Returns if the message was removed\n     */\n\n  }, {\n    key: \"removeMessage\",\n    value: function removeMessage(messageToRemove) {\n      var removed = false;\n      var messages = this.messages.flatMap(function (message) {\n        var idMatch = message.id && messageToRemove.id && message.id === messageToRemove.id;\n\n        if (idMatch) {\n          return [];\n        } else {\n          removed = true;\n          return message;\n        }\n      });\n      this.messages = messages;\n      return removed;\n    }\n    /**\n     * filterErrorMessages - Removes error messages from the channel state.\n     *\n     */\n\n  }, {\n    key: \"filterErrorMessages\",\n    value: function filterErrorMessages() {\n      var filteredMessages = this.messages.flatMap(function (message) {\n        if (message.type !== 'error') {\n          return message;\n        } else {\n          return [];\n        }\n      });\n      this.messages = Immutable(filteredMessages);\n    }\n    /**\n     * clean - Remove stale data such as users that stayed in typing state for more than 5 seconds\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      var now = new Date(); // prevent old users from showing up as typing\n\n      var _arr = Object.entries(this.typing);\n\n      for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n        var _arr$_i = _slicedToArray(_arr[_i3], 2),\n            userID = _arr$_i[0],\n            lastEvent = _arr$_i[1];\n\n        var since = now - new Date(lastEvent.received_at);\n\n        if (since > 7000) {\n          this.typing = this.typing.without(userID);\n\n          this._channel.client.dispatchEvent({\n            type: 'typing.stop',\n            user: {\n              id: userID\n            },\n            cid: this._channel.cid\n          });\n        }\n      }\n    }\n  }]);\n\n  return ChannelState;\n}();\n\nvar EVENT_MAP = {\n  'user.presence.changed': true,\n  'user.watching.start': true,\n  'user.watching.stop': true,\n  'user.updated': true,\n  'typing.start': true,\n  'typing.stop': true,\n  'message.new': true,\n  'message.updated': true,\n  'message.deleted': true,\n  'message.read': true,\n  'message.reaction': true,\n  'member.added': true,\n  'member.updated': true,\n  'member.removed': true,\n  'channel.updated': true,\n  'health.check': true,\n  'notification.message_new': true,\n  'notification.mark_read': true,\n  'notification.invited': true,\n  'notification.invite_accepted': true,\n  'notification.added_to_channel': true,\n  'notification.removed_from_channel': true,\n  // local events\n  'connection.changed': true,\n  'connection.recovered': true\n};\n\nfunction isValidEventType(eventType) {\n  if (eventType === 'all') {\n    return true;\n  }\n\n  return EVENT_MAP[eventType] || false;\n}\n/**\n * logChatPromiseExecution - utility function for logging the execution of a promise..\n *  use this when you want to run the promise and handle errors by logging a warning\n *\n * @param {type} promise The promise you want to run and log\n * @param {type} name    A descriptive name of what the promise does for log output\n *\n */\n\n\nfunction logChatPromiseExecution(promise, name) {\n  promise.then(function () {// do nothing...\n  }).catch(function (error) {\n    console.warn(\"failed to do \".concat(name, \", ran into error: \"), error);\n  });\n}\n\nvar sleep = function sleep(m) {\n  return new Promise(function (r) {\n    return setTimeout(r, m);\n  });\n};\n/**\n * Channel - The Channel class manages it's own state.\n */\n\n\nvar Channel =\n/*#__PURE__*/\nfunction () {\n  /**\n   * constructor - Create a channel\n   *\n   * @param {Client} client the chat client\n   * @param {string} type  the type of channel\n   * @param {string} [id]  the id of the chat\n   * @param {type} custom any additional custom params\n   *\n   * @return {Channel} Returns a new uninitialized channel\n   */\n  function Channel(client, type, id, data) {\n    var _this = this;\n\n    _classCallCheck(this, Channel);\n\n    _defineProperty(this, \"create\",\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var options;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = {\n                watch: false,\n                state: false,\n                presence: false\n              };\n              _context.next = 3;\n              return _this.query(options);\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    })));\n\n    _defineProperty(this, \"_channelURL\", function () {\n      if (!_this.id) {\n        throw new Error('channel id is not defined');\n      }\n\n      var channelURL = \"\".concat(_this.client.baseURL, \"/channels/\").concat(_this.type, \"/\").concat(_this.id);\n      return channelURL;\n    });\n\n    var validTypeRe = /^[\\w_-]+$/;\n    var validIDRe = /^[\\w!_-]+$/;\n\n    if (!validTypeRe.test(type)) {\n      throw new Error(\"Invalid chat type \".concat(type, \", letters, numbers and \\\"_-\\\" are allowed\"));\n    }\n\n    if (!validIDRe.test(id)) {\n      throw new Error(\"Invalid chat id \".concat(id, \", letters, numbers and \\\"!-_\\\" are allowed\"));\n    }\n\n    this.client = client;\n    this.type = type;\n    this.id = id; // used by the frontend, gets updated:\n\n    this.data = data; // this._data is used for the requests...\n\n    this._data = _objectSpread({}, data);\n    this.cid = \"\".concat(type, \":\").concat(id);\n    this.listeners = {}; // perhaps the state variable should be private\n\n    this.state = new ChannelState(this);\n    this.initialized = false;\n    this.lastTypingEvent = null;\n    this.isTyping = false;\n  }\n  /**\n   * getConfig - Get the configs for this channel type\n   *\n   * @return {object}\n   */\n\n\n  _createClass(Channel, [{\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.client.configs[this.type];\n    }\n    /**\n     * sendMessage - Send a message to this channel\n     *\n     * @param {object} message The Message object\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(message) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.client.post(this._channelURL() + '/message', {\n                  message: message\n                });\n\n              case 2:\n                data = _context2.sent;\n                return _context2.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sendMessage(_x) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n  }, {\n    key: \"sendFile\",\n    value: function sendFile(uri, name, contentType, user) {\n      return this.client.sendFile(\"\".concat(this._channelURL(), \"/file\"), uri, name, contentType, user);\n    }\n  }, {\n    key: \"sendImage\",\n    value: function sendImage(uri, name, contentType, user) {\n      return this.client.sendFile(\"\".concat(this._channelURL(), \"/image\"), uri, name, contentType, user);\n    }\n  }, {\n    key: \"deleteFile\",\n    value: function deleteFile(url) {\n      return this.client.delete(\"\".concat(this._channelURL(), \"/file\"), {\n        url: url\n      });\n    }\n  }, {\n    key: \"deleteImage\",\n    value: function deleteImage(url) {\n      return this.client.delete(\"\".concat(this._channelURL(), \"/image\"), {\n        url: url\n      });\n    }\n    /**\n     * sendEvent - Send an event on this channel\n     *\n     * @param {object} chatEvent for example {type: 'message.read'}\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"sendEvent\",\n    value: function () {\n      var _sendEvent = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(chatEvent) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._checkInitialized();\n\n                _context3.next = 3;\n                return this.client.post(this._channelURL() + '/event', {\n                  event: chatEvent\n                });\n\n              case 3:\n                data = _context3.sent;\n                return _context3.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sendEvent(_x2) {\n        return _sendEvent.apply(this, arguments);\n      }\n\n      return sendEvent;\n    }()\n    /**\n     * sendReaction - Send a reaction about a message\n     *\n     * @param {string} messageID the message id\n     * @param {object} reaction the reaction object for instance {type: 'love'}\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"sendReaction\",\n    value: function () {\n      var _sendReaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(messageID, reaction) {\n        var body, data;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (messageID) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw Error(\"Message id is missing\");\n\n              case 2:\n                if (!(!reaction || Object.keys(reaction).length === 0)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw Error(\"Reaction object is missing\");\n\n              case 4:\n                body = {\n                  reaction: reaction\n                };\n                _context4.next = 7;\n                return this.client.post(this.client.baseURL + \"/messages/\".concat(messageID, \"/reaction\"), body);\n\n              case 7:\n                data = _context4.sent;\n                return _context4.abrupt(\"return\", data);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function sendReaction(_x3, _x4) {\n        return _sendReaction.apply(this, arguments);\n      }\n\n      return sendReaction;\n    }()\n    /**\n     * deleteReaction - Delete a reaction by user and type\n     *\n     * @param {string} messageID the id of the message from which te remove the reaction\n     * @param {string} reactionType the type of reaction that should be removed\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"deleteReaction\",\n    value: function deleteReaction(messageID, reactionType) {\n      this._checkInitialized();\n\n      if (!reactionType || !messageID) {\n        throw Error('Deleting a reaction requires specifying both the message and reaction type');\n      }\n\n      var url = this.client.baseURL + \"/messages/\".concat(messageID, \"/reaction/\").concat(reactionType);\n      return this.client.delete(url);\n    }\n    /**\n     * update - Edit the channel's custom properties\n     *\n     * @param {object} custom The object to update the custom properties of this channel with\n     *\n     * @return {type} The server response\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(channelData, updateMessage) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.client.post(this._channelURL(), {\n                  message: updateMessage,\n                  data: channelData\n                });\n\n              case 2:\n                data = _context5.sent;\n                this.data = data.channel;\n                return _context5.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function update(_x5, _x6) {\n        return _update.apply(this, arguments);\n      }\n\n      return update;\n    }()\n    /**\n     * delete - Delete the channel.. Messages are permanently removed.\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6() {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.client.delete(this._channelURL());\n\n              case 2:\n                data = _context6.sent;\n                return _context6.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * truncate - Removes all messages from the channel\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"truncate\",\n    value: function () {\n      var _truncate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7() {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.client.post(this._channelURL() + '/truncate');\n\n              case 2:\n                data = _context7.sent;\n                return _context7.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function truncate() {\n        return _truncate.apply(this, arguments);\n      }\n\n      return truncate;\n    }()\n  }, {\n    key: \"acceptInvite\",\n    value: function () {\n      var _acceptInvite = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8() {\n        var options,\n            data,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n                _context8.next = 3;\n                return this.client.post(this._channelURL(), _objectSpread({\n                  accept_invite: true\n                }, options));\n\n              case 3:\n                data = _context8.sent;\n                this.data = data.channel;\n                return _context8.abrupt(\"return\", data);\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function acceptInvite() {\n        return _acceptInvite.apply(this, arguments);\n      }\n\n      return acceptInvite;\n    }()\n  }, {\n    key: \"rejectInvite\",\n    value: function () {\n      var _rejectInvite = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9() {\n        var options,\n            data,\n            _args9 = arguments;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                options = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {};\n                _context9.next = 3;\n                return this.client.post(this._channelURL(), _objectSpread({\n                  reject_invite: true\n                }, options));\n\n              case 3:\n                data = _context9.sent;\n                this.data = data.channel;\n                return _context9.abrupt(\"return\", data);\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function rejectInvite() {\n        return _rejectInvite.apply(this, arguments);\n      }\n\n      return rejectInvite;\n    }()\n  }, {\n    key: \"addMembers\",\n    value: function () {\n      var _addMembers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.client.post(this._channelURL(), {\n                  add_members: members\n                });\n\n              case 2:\n                data = _context10.sent;\n                this.data = data.channel;\n                return _context10.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function addMembers(_x7) {\n        return _addMembers.apply(this, arguments);\n      }\n\n      return addMembers;\n    }()\n  }, {\n    key: \"addModerators\",\n    value: function () {\n      var _addModerators = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.client.post(this._channelURL(), {\n                  add_moderators: members\n                });\n\n              case 2:\n                data = _context11.sent;\n                this.data = data.channel;\n                return _context11.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function addModerators(_x8) {\n        return _addModerators.apply(this, arguments);\n      }\n\n      return addModerators;\n    }()\n  }, {\n    key: \"removeMembers\",\n    value: function () {\n      var _removeMembers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.client.post(this._channelURL(), {\n                  remove_members: members\n                });\n\n              case 2:\n                data = _context12.sent;\n                this.data = data.channel;\n                return _context12.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function removeMembers(_x9) {\n        return _removeMembers.apply(this, arguments);\n      }\n\n      return removeMembers;\n    }()\n  }, {\n    key: \"demoteModerators\",\n    value: function () {\n      var _demoteModerators = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.client.post(this._channelURL(), {\n                  demote_moderators: members\n                });\n\n              case 2:\n                data = _context13.sent;\n                this.data = data.channel;\n                return _context13.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function demoteModerators(_x10) {\n        return _demoteModerators.apply(this, arguments);\n      }\n\n      return demoteModerators;\n    }()\n  }, {\n    key: \"sendAction\",\n    value: function sendAction(messageID, formData) {\n      this._checkInitialized();\n\n      if (!messageID) {\n        throw Error(\"Message id is missing\");\n      }\n\n      return this.client.post(this.client.baseURL + \"/messages/\".concat(messageID, \"/action\"), {\n        message_id: messageID,\n        form_data: formData,\n        id: this.id,\n        type: this.type\n      });\n    }\n    /**\n     * keystroke - First of the typing.start and typing.stop events based on the users keystrokes.\n     *  Call this on every keystroke\n     */\n\n  }, {\n    key: \"keystroke\",\n    value: function () {\n      var _keystroke = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14() {\n        var now, diff;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (this.getConfig().typing_events) {\n                  _context14.next = 2;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\");\n\n              case 2:\n                now = new Date();\n                diff = now - this.lastTypingEvent;\n                this.lastKeyStroke = now;\n                this.isTyping = true; // send a typing.start every 2 seconds\n\n                if (!(diff > 2000)) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                this.lastTypingEvent = new Date();\n                _context14.next = 10;\n                return this.sendEvent({\n                  type: 'typing.start'\n                });\n\n              case 10:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function keystroke() {\n        return _keystroke.apply(this, arguments);\n      }\n\n      return keystroke;\n    }()\n    /**\n     * stopTyping - Sets last typing to null and sends the typing.stop event\n     */\n\n  }, {\n    key: \"stopTyping\",\n    value: function () {\n      var _stopTyping = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee15() {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (this.getConfig().typing_events) {\n                  _context15.next = 2;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\");\n\n              case 2:\n                this.lastTypingEvent = null;\n                this.isTyping = false;\n                _context15.next = 6;\n                return this.sendEvent({\n                  type: 'typing.stop'\n                });\n\n              case 6:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function stopTyping() {\n        return _stopTyping.apply(this, arguments);\n      }\n\n      return stopTyping;\n    }()\n    /**\n     * lastMessage - return the last message, takes into account that last few messages might not be perfectly sorted\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"lastMessage\",\n    value: function lastMessage() {\n      // get last 5 messages, sort, return the latest\n      // get a slice of the last 5\n      var min = this.state.messages.length - 5;\n\n      if (min < 0) {\n        min = 0;\n      }\n\n      var max = this.state.messages.length + 1;\n      var messageSlice = this.state.messages.slice(min, max).asMutable(); // sort by pk desc\n\n      messageSlice.sort(function (a, b) {\n        return b.created_at - a.created_at;\n      });\n      var lastMessage;\n\n      if (messageSlice.length > 0) {\n        lastMessage = messageSlice[0];\n      }\n\n      return lastMessage;\n    }\n    /**\n     * markRead - Send the mark read event for this user, only works if the `read_events` setting is enabled\n     *\n     * @return {Promise} Description\n     */\n\n  }, {\n    key: \"markRead\",\n    value: function markRead() {\n      this._checkInitialized();\n\n      if (!this.getConfig().read_events) {\n        return Promise.resolve(null);\n      }\n\n      var lastMessage = this.lastMessage();\n      var lastMessageCreatedAt, lastMessageID;\n\n      if (lastMessage) {\n        lastMessageCreatedAt = lastMessage.created_at;\n        lastMessageID = lastMessage.id;\n      }\n\n      return this.sendEvent({\n        type: 'message.read',\n        lastMessageID: lastMessageID,\n        lastMessageCreatedAt: lastMessageCreatedAt\n      });\n    }\n    /**\n     * clean - Cleans the channel state and fires stop typing if needed\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      if (this.lastKeyStroke) {\n        var now = new Date();\n        var diff = now - this.lastKeyStroke;\n\n        if (diff > 1000 && this.isTyping) {\n          logChatPromiseExecution(this.stopTyping(), 'stop typing event');\n        }\n      }\n\n      this.state.clean();\n    }\n    /**\n     * watch - Loads the initial channel state and watches for changes\n     *\n     * @param {object} options additional options for the query endpoint\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"watch\",\n    value: function () {\n      var _watch = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(options) {\n        var defaultOptions, combined, state;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                defaultOptions = {\n                  state: true,\n                  watch: true,\n                  presence: false\n                };\n\n                if (!this.client._hasClientID()) {\n                  defaultOptions.watch = false;\n                }\n\n                combined = _objectSpread({}, defaultOptions, options);\n                _context16.next = 5;\n                return this.query(combined);\n\n              case 5:\n                state = _context16.sent;\n                this.initialized = true;\n\n                this._initializeState(state);\n\n                return _context16.abrupt(\"return\", state);\n\n              case 9:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function watch(_x11) {\n        return _watch.apply(this, arguments);\n      }\n\n      return watch;\n    }()\n    /**\n     * stopwatching - Stops watching the channel\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"stopWatching\",\n    value: function () {\n      var _stopWatching = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17() {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.client.post(this._channelURL() + '/stop-watching', {});\n\n              case 2:\n                response = _context17.sent;\n                return _context17.abrupt(\"return\", response);\n\n              case 4:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function stopWatching() {\n        return _stopWatching.apply(this, arguments);\n      }\n\n      return stopWatching;\n    }()\n    /**\n     * getReplies - Description\n     *\n     * @param {type} parent_id The message parent id, ie the top of the thread\n     * @param {type} options   Pagination params, ie {limit:10, idlte: 10}\n     *\n     * @return {type} A response with a list of messages\n     */\n\n  }, {\n    key: \"getReplies\",\n    value: function () {\n      var _getReplies = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(parent_id, options) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.client.get(this.client.baseURL + \"/messages/\".concat(parent_id, \"/replies\"), _objectSpread({}, options));\n\n              case 2:\n                data = _context18.sent; // add any messages to our thread state\n\n                if (data.messages) {\n                  this.state.addMessagesSorted(data.messages);\n                }\n\n                return _context18.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function getReplies(_x12, _x13) {\n        return _getReplies.apply(this, arguments);\n      }\n\n      return getReplies;\n    }()\n    /**\n     * getReactions - List the reactions, supports pagination\n     *\n     * @param {string} message_id The message id\n     * @param {object} options    The pagination options\n     *\n     * @return {object} Server response\n     */\n\n  }, {\n    key: \"getReactions\",\n    value: function () {\n      var _getReactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee19(message_id, options) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.client.get(this.client.baseURL + \"/messages/\".concat(message_id, \"/reactions\"), _objectSpread({}, options));\n\n              case 2:\n                data = _context19.sent;\n                return _context19.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getReactions(_x14, _x15) {\n        return _getReactions.apply(this, arguments);\n      }\n\n      return getReactions;\n    }()\n    /**\n     * countUnread - Count the number of messages with a date thats newer than the last read timestamp\n     *\n     * @param {date} lastRead the time that the user read a message\n     *\n     * @return {int} Unread count\n     */\n\n  }, {\n    key: \"countUnread\",\n    value: function countUnread(lastRead) {\n      var count = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.state.messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var m = _step.value;\n\n          if (m.created_at > lastRead) {\n            count++;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\n     * create - Description\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"query\",\n\n    /**\n     * query - Query the API, get messages, members or other channel fields\n     *\n     * @param {object} options The query options\n     *\n     * @return {object} Returns a query response\n     */\n    value: function () {\n      var _query = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee20(options) {\n        var queryURL, state;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return Promise.resolve(this.client.wsPromise);\n\n              case 2:\n                queryURL = \"\".concat(this.client.baseURL, \"/channels/\").concat(this.type);\n\n                if (this.id) {\n                  queryURL += \"/\".concat(this.id);\n                }\n\n                _context20.next = 6;\n                return this.client.post(queryURL + '/query', _objectSpread({\n                  data: this._data,\n                  state: true\n                }, options));\n\n              case 6:\n                state = _context20.sent; // update the channel id if it was missing\n\n                if (!this.id) {\n                  this.id = state.channel.id;\n                  this.cid = state.channel.cid; // set the channel as active...\n\n                  if (!(this.cid in this.client.activeChannels)) {\n                    this.client.activeChannels[this.cid] = this;\n                  }\n                }\n\n                this.client._addChannelConfig(state); // add any messages to our channel state\n\n\n                this._initializeState(state);\n\n                return _context20.abrupt(\"return\", state);\n\n              case 11:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function query(_x16) {\n        return _query.apply(this, arguments);\n      }\n\n      return query;\n    }()\n    /**\n     * banUser - Bans a user from a channel\n     *\n     * @param targetUserID\n     * @param options\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"banUser\",\n    value: function () {\n      var _banUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee21(targetUserID, options) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                this._checkInitialized();\n\n                _context21.next = 3;\n                return this.client.banUser(targetUserID, _objectSpread({}, options, {\n                  type: this.type,\n                  id: this.id\n                }));\n\n              case 3:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 4:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function banUser(_x17, _x18) {\n        return _banUser.apply(this, arguments);\n      }\n\n      return banUser;\n    }()\n    /**\n     * banUser - Removes the bans for a user on a channel\n     *\n     * @param targetUserID\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"unbanUser\",\n    value: function () {\n      var _unbanUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee22(targetUserID) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                this._checkInitialized();\n\n                _context22.next = 3;\n                return this.client.unbanUser(targetUserID, {\n                  type: this.type,\n                  id: this.id\n                });\n\n              case 3:\n                return _context22.abrupt(\"return\", _context22.sent);\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function unbanUser(_x19) {\n        return _unbanUser.apply(this, arguments);\n      }\n\n      return unbanUser;\n    }()\n    /**\n     * on - Listen to events on this channel.\n     *\n     * channel.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n     * or\n     * channel.on(event => {console.log(event.type)})\n     *\n     * @param {string} callbackOrString  The event type to listen for (optional)\n     * @param {function} callbackOrNothing The callback to call\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(callbackOrString, callbackOrNothing) {\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this.listeners[key].push(callback);\n    }\n    /**\n     * off - Remove the event handler\n     *\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(callbackOrString, callbackOrNothing) {\n      this._checkInitialized();\n\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this.listeners[key] = this.listeners[key].filter(function (value) {\n        return value !== callback;\n      });\n    }\n  }, {\n    key: \"_handleChannelEvent\",\n    value: function _handleChannelEvent(event) {\n      var channel = this;\n      var messageUpdateEvent = {\n        'message.updated': true,\n        'message.deleted': true,\n        'message.reaction': true\n      };\n      var s = channel.state;\n\n      if (event.type === 'typing.start') {\n        s.typing = s.typing.set(event.user.id, Immutable(event));\n      } else if (event.type === 'typing.stop') {\n        s.typing = s.typing.without(event.user.id);\n      } else if (event.type === 'message.read') {\n        s.read = s.read.set(event.user.id, Immutable(event));\n      } else if (event.type === 'user.watching.start' || event.types === 'user.updated') {\n        s.watchers = s.watchers.set(event.user.id, Immutable(event.user));\n      } else if (event.type === 'user.watching.stop') {\n        s.watchers = s.watchers.without(event.user.id);\n      } else if (event.type === 'message.new') {\n        s.addMessageSorted(event.message);\n      } else if (event.type in messageUpdateEvent) {\n        s.addMessageSorted(event.message);\n      } else if (event.type === 'member.added' || event.type === 'member.updated') {\n        s.members = s.members.set(event.member.id, Immutable(event.member));\n      } else if (event.type === 'member.removed') {\n        s.members = s.members.without(event.user.id);\n      } else if (event.type === 'channel.updated') {\n        channel.data = Immutable(event.channel);\n      } // any event can send over the online count\n\n\n      if (event.watcher_count !== undefined) {\n        channel.state.watcher_count = event.watcher_count;\n      } // gather and call the listeners\n\n\n      var listeners = [];\n\n      if (channel.listeners.all) {\n        listeners.push.apply(listeners, _toConsumableArray(channel.listeners.all));\n      }\n\n      if (channel.listeners[event.type]) {\n        listeners.push.apply(listeners, _toConsumableArray(channel.listeners[event.type]));\n      } // call the event and send it to the listeners\n\n\n      for (var _i = 0; _i < listeners.length; _i++) {\n        var listener = listeners[_i];\n        listener(event);\n      }\n    }\n    /**\n     * _channelURL - Returns the channel url\n     *\n     * @return {string} The channel url\n     */\n\n  }, {\n    key: \"_checkInitialized\",\n    value: function _checkInitialized() {\n      if (!this.initialized && !this.client._isUsingServerAuth()) {\n        throw Error(\"Channel \".concat(this.cid, \" hasn't been initialized yet. Make sure to call .watch() and wait for it to resolve\"));\n      }\n    }\n  }, {\n    key: \"_initializeState\",\n    value: function _initializeState(state) {\n      // immutable list of maps\n      var messages = state.messages || [];\n\n      if (!this.state.messages) {\n        this.state.messages = Immutable([]);\n      }\n\n      this.state.addMessagesSorted(messages);\n      this.state.watcher_count = state.watcher_count; // convert the arrays into objects for easier syncing...\n\n      if (state.watchers) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = state.watchers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var watcher = _step2.value;\n            this.state.watchers = this.state.watchers.set(watcher.id, watcher);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      if (state.read) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = state.read[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var read = _step3.value;\n            this.state.read = this.state.read.set(read.user.id, read);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      if (state.members) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = state.members[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var m = _step4.value;\n            this.state.members = this.state.members.set(m.id, m);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return Channel;\n}();\n/**\n * ClientState - A container class for the client state.\n */\n\n\nvar ClientState =\n/*#__PURE__*/\nfunction () {\n  function ClientState() {\n    _classCallCheck(this, ClientState); // show the status for a certain user...\n    // ie online, offline etc\n\n\n    this.users = Immutable({});\n  }\n\n  _createClass(ClientState, [{\n    key: \"updateUser\",\n    value: function updateUser(user) {\n      if (user != null) {\n        this.users = this.users.set(user.id, Immutable(user));\n      }\n    }\n  }]);\n\n  return ClientState;\n}();\n/**\n * StableWSConnection - A WS connection that reconnects upon failure.\n * - the browser will sometimes report that you're online or offline\n * - the WS connection can break and fail (there is a 30s health check)\n * - sometimes your WS connection will seem to work while the user is in fact offline\n * - to speed up online/offline detection you can use the window.addEventListener('offline');\n *\n * There are 4 ways in which a connection can become unhealthy:\n * - websocket.onerror is called\n * - websocket.onclose is called\n * - the health check fails and no event is received for ~40 seconds\n * - the browser indicates the connection is now offline\n *\n * There are 2 assumptions we make about the server:\n * - state can be recovered by querying the channel again\n * - if the servers fails to publish a message to the client, the WS connection is destroyed\n */\n\n\nvar StableWSConnection =\n/*#__PURE__*/\nfunction () {\n  function StableWSConnection(_ref) {\n    var _this = this;\n\n    var wsURL = _ref.wsURL,\n        clientID = _ref.clientID,\n        userID = _ref.userID,\n        messageCallback = _ref.messageCallback,\n        recoverCallback = _ref.recoverCallback,\n        eventCallback = _ref.eventCallback;\n\n    _classCallCheck(this, StableWSConnection);\n\n    _defineProperty(this, \"onlineStatusChanged\", function (event) {\n      if (event.type === 'offline') {\n        // mark the connection as down\n        _this._setHealth(false);\n      } else if (event.type === 'online') {\n        // retry right now...\n        // We check this.isHealthy, not sure if it's always\n        // smart to create a new WS connection if the old one is still up and running.\n        // it's possible we didnt miss any messages, so this process is just expensive and not needed.\n        if (!_this.isHealthy) {\n          _this._reconnect(10);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onopen\", function (wsID) {\n      if (_this.wsID !== wsID) return; // set healthy..\n\n      _this._setHealth(true);\n    });\n\n    _defineProperty(this, \"onmessage\", function (wsID, event) {\n      if (_this.wsID !== wsID) return; // we wait till the first message before we consider the connection open..\n      // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately\n      // after that a ws.onclose..\n\n      if (!_this.isResolved) {\n        _this.resolvePromise(event);\n      } // trigger the event..\n\n\n      _this.lastEvent = new Date();\n\n      _this.messageCallback(event);\n    });\n\n    _defineProperty(this, \"onclose\", function (wsID, event) {\n      if (_this.wsID !== wsID) return;\n\n      if (event.code === 1000) {\n        // this is a permanent error raised by stream..\n        // usually caused by invalid auth details\n        var error = new Error(\"WS connection reject with error \".concat(event.reason));\n        error.reason = event.reason;\n\n        _this.rejectPromise(error);\n      } else {\n        _this.consecutiveFailures += 1;\n        _this.totalFailures += 1;\n\n        _this._setHealth(false);\n\n        _this.rejectPromise(_this._errorFromWSEvent(event)); // reconnect if its an abnormal failure\n\n\n        _this._reconnect();\n      }\n    });\n\n    _defineProperty(this, \"onerror\", function (wsID, event) {\n      if (_this.wsID !== wsID) return;\n      _this.consecutiveFailures += 1;\n      _this.totalFailures += 1;\n\n      _this._setHealth(false);\n\n      _this.rejectPromise(_this._errorFromWSEvent(event));\n\n      _this._reconnect();\n    });\n\n    _defineProperty(this, \"_setHealth\", function (healthy) {\n      if (healthy && !_this.isHealthy) {\n        // yee we are online:\n        _this.isHealthy = true;\n\n        _this.eventCallback({\n          type: 'connection.changed',\n          online: true\n        });\n      }\n\n      if (!healthy && _this.isHealthy) {\n        // bummer we are offline\n        _this.isHealthy = false;\n\n        _this.eventCallback({\n          type: 'connection.changed',\n          online: false\n        });\n      }\n    });\n\n    _defineProperty(this, \"_errorFromWSEvent\", function (event) {\n      var error = new Error(\"WS failed with code \".concat(event.code));\n      error.code = event.code;\n      error.isWSFailure = true;\n      return error;\n    });\n\n    _defineProperty(this, \"_listenForConnectionChanges\", function () {\n      if (typeof window !== 'undefined' && window != null && window.addEventListener != null) {\n        window.addEventListener('offline', _this.onlineStatusChanged);\n        window.addEventListener('online', _this.onlineStatusChanged);\n      }\n    });\n\n    _defineProperty(this, \"_removeConnectionListeners\", function () {\n      if (typeof window !== 'undefined' && window != null && window.addEventListener != null) {\n        window.removeEventListener('offline', _this.onlineStatusChanged);\n        window.removeEventListener('online', _this.onlineStatusChanged);\n      }\n    });\n\n    _defineProperty(this, \"_setupConnectionPromise\", function () {\n      var that = _this;\n      _this.isResolved = false;\n      /** a promise that is resolved once ws.open is called */\n\n      _this.connectionOpen = new Promise(function (resolve, reject) {\n        that.resolvePromise = resolve;\n        that.rejectPromise = reject;\n      }).then(function (e) {\n        var data = JSON.parse(e.data);\n\n        if (data.error != null) {\n          throw new Error(JSON.stringify(data.error));\n        }\n\n        return data;\n      });\n    });\n\n    this.wsURL = wsURL;\n    this.clientID = clientID;\n    this.userID = userID;\n    /** consecutive failures influence the duration of the timeout */\n\n    this.consecutiveFailures = 0;\n    /** keep track of the total number of failures */\n\n    this.totalFailures = 0;\n    /** We only make 1 attempt to reconnect at the same time.. */\n\n    this.isConnecting = false;\n    /** Boolean that indicates if we have a working connection to the server */\n\n    this.isHealthy = false;\n    /** Callback when the connection fails and recovers */\n\n    this.recoverCallback = recoverCallback;\n    this.messageCallback = messageCallback;\n    this.eventCallback = eventCallback;\n    /** Incremented when a new WS connection is made */\n\n    this.wsID = 1;\n    /** Store the last event time for health checks */\n\n    this.lastEvent = null;\n    /** Send a health check message every 30 seconds */\n\n    this.healthCheckInterval = 30 * 1000;\n    /** Every second we verify that we didn't miss any health checks */\n\n    this.monitorInterval = 1 * 1000;\n\n    this._listenForConnectionChanges();\n  }\n  /**\n   * connect - Connect to the WS URL\n   *\n   * @return {promise} Promise that completes once the first health check message is received\n   */\n\n\n  _createClass(StableWSConnection, [{\n    key: \"connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var healthCheck;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.isConnecting) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw Error(\"You've called connect twice, can only attempt 1 connection at the time\");\n\n              case 2:\n                _context.prev = 2;\n                this.isConnecting = true;\n                _context.next = 6;\n                return this._connect();\n\n              case 6:\n                healthCheck = _context.sent;\n                this.isConnecting = false;\n                this.consecutiveFailures = 0;\n\n                this._startMonitor();\n\n                this._startHealthCheck();\n\n                return _context.abrupt(\"return\", healthCheck);\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](2); // This is a permanent failure, throw the error...\n\n                this.isConnecting = false;\n\n                if (_context.t0.isWSFailure) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 14]]);\n      }));\n\n      function connect() {\n        return _connect2.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * disconnect - Disconnect the connection and doesn't recover...\n     *\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      // start by removing all the listeners\n      if (this.healthCheckIntervalRef) {\n        clearInterval(this.healthCheckIntervalRef);\n      }\n\n      if (this.monitorIntervalRef) {\n        clearInterval(this.monitorIntervalRef);\n      }\n\n      this._removeConnectionListeners(); // reset the wsID;\n\n\n      this.wsID = 1;\n      this.isHealthy = false; // remove ws handlers...\n\n      if (this.ws && this.ws.removeAllListeners) {\n        this.ws.removeAllListeners();\n      } // and finally close...\n\n\n      if (this.ws && this.ws.close) {\n        this.ws.close(1000, 'Manually closed connection by calling client.disconnect()');\n      }\n\n      delete this.ws;\n    }\n    /**\n     * _connect - Connect to the WS endpoint\n     *\n     * @return {promise} Promise that completes once the first health check message is received\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect() {\n      this._setupConnectionPromise();\n\n      this.ws = new isoWS(this.wsURL);\n      this.ws.onopen = this.onopen.bind(this, this.wsID);\n      this.ws.onclose = this.onclose.bind(this, this.wsID);\n      this.ws.onerror = this.onerror.bind(this, this.wsID);\n      this.ws.onmessage = this.onmessage.bind(this, this.wsID);\n      return this.connectionOpen;\n    }\n    /**\n     * _reconnect - Description\n     *\n     * @param {int} interval number of ms to wait before connecting\n     */\n\n  }, {\n    key: \"_reconnect\",\n    value: function () {\n      var _reconnect2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(interval) {\n        var open;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.isConnecting || this.isHealthy)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                this.isConnecting = true; // reconnect in case of on error or on close\n                // also reconnect if the health check cycle fails\n\n                if (interval === undefined) {\n                  interval = this._retryInterval();\n                } // cleanup the old connection\n\n\n                this._destroyCurrentWSConnection(); // reconnect, or try again after a little while...\n\n\n                _context2.next = 7;\n                return sleep(interval);\n\n              case 7:\n                _context2.prev = 7;\n                _context2.next = 10;\n                return this._connect();\n\n              case 10:\n                open = _context2.sent;\n\n                if (!this.recoverCallback) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                _context2.next = 14;\n                return this.recoverCallback(open);\n\n              case 14:\n                this.isConnecting = false;\n                this.consecutiveFailures = 0;\n                _context2.next = 23;\n                break;\n\n              case 18:\n                _context2.prev = 18;\n                _context2.t0 = _context2[\"catch\"](7);\n                this.isConnecting = false;\n                console.warn(\"reconnect failed with error\", _context2.t0); // reconnect on WS failures, dont reconnect if there is a code bug\n\n                if (_context2.t0.isWSFailure) {\n                  this._reconnect();\n                }\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[7, 18]]);\n      }));\n\n      function _reconnect(_x) {\n        return _reconnect2.apply(this, arguments);\n      }\n\n      return _reconnect;\n    }()\n    /**\n     * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.\n     *\n     * @param {object} event Event with type online or offline\n     *\n     */\n\n  }, {\n    key: \"_destroyCurrentWSConnection\",\n\n    /**\n     * _destroyCurrentWSConnection - Removes the current WS connnection\n     *\n     */\n    value: function _destroyCurrentWSConnection() {\n      // increment the ID, meaning we will ignore all messages from the old\n      // ws connection from now on.\n      this.wsID += 1;\n\n      try {\n        if (this.ws && this.ws.removeAllListeners) {\n          this.ws.removeAllListeners();\n        }\n\n        if (this.ws && this.ws.close) {\n          this.ws.close();\n        }\n      } catch (e) {// we dont care\n      }\n    }\n    /**\n     * _retryInterval - A retry interval which increases after consecutive failures\n     *\n     * @return {int} Duration to wait in milliseconds\n     */\n\n  }, {\n    key: \"_retryInterval\",\n    value: function _retryInterval() {\n      // try to reconnect in 0-5 seconds (random to spread out the load from failures)\n      var max = this.consecutiveFailures * 5000;\n\n      if (max > 25000) {\n        max = 25000;\n      }\n\n      var min = (this.consecutiveFailures - 1) * 5000;\n      var interval = Math.round(Math.random() * (max - min) + min);\n\n      if (interval < 1000) {\n        interval = 1000;\n      }\n\n      return interval;\n    }\n    /**\n     * _setupPromise - sets up the this.connectOpen promise\n     */\n\n  }, {\n    key: \"_startHealthCheck\",\n\n    /**\n     * _startHealthCheck - Sends a message every 30s or so to see if the ws connection still works\n     *\n     */\n    value: function _startHealthCheck() {\n      var that = this; // 30 seconds is the recommended interval (messenger uses this)\n\n      this.healthCheckIntervalRef = setInterval(function () {\n        // send the healthcheck.., server replies with a health check event\n        var data = [{\n          type: 'health.check',\n          clientID: that.clientID,\n          userID: that.userID\n        }]; // try to send on the connection\n\n        try {\n          that.ws.send(JSON.stringify(data));\n        } catch (e) {// error will already be detected elsewhere\n        }\n      }, that.healthCheckInterval);\n    }\n    /**\n     * _startMonitor - Verifies we didn't miss any events. Marks the connection as failed in case we did.\n     *\n     */\n\n  }, {\n    key: \"_startMonitor\",\n    value: function _startMonitor() {\n      var _this2 = this;\n\n      var that = this;\n      this.monitorIntervalRef = setInterval(function () {\n        var now = new Date(); // means we missed a health check\n\n        if (now - that.lastEvent > _this2.healthCheckInterval + 10 * 1000) {\n          that._setHealth(false);\n\n          that._reconnect();\n        }\n      }, that.monitorInterval);\n    }\n  }]);\n\n  return StableWSConnection;\n}();\n\nvar jwt = null;\nvar crypto = null;\n/**\n * Creates the JWT token that can be used for a UserSession\n * @method JWTUserSessionToken\n * @memberof signing\n * @private\n * @param {string} apiSecret - API Secret key\n * @param {string} userId - The user_id key in the JWT payload\n * @param {object} [extraData] - Extra that should be part of the JWT token\n * @param {object} [jwtOptions] - Options that can be past to jwt.sign\n * @return {string} JWT Token\n */\n\nfunction JWTUserToken(apiSecret, userId) {\n  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var jwtOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (typeof userId !== 'string') {\n    throw new TypeError('userId should be a string');\n  }\n\n  var payload = _objectSpread({\n    user_id: userId\n  }, extraData);\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  return jwt.sign(payload, apiSecret, opts);\n}\n\nfunction JWTServerToken(apiSecret) {\n  var jwtOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var payload = {\n    server: true\n  };\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  return jwt.sign(payload, apiSecret, opts);\n}\n\nfunction decodeBase64(s) {\n  var e = {},\n      w = String.fromCharCode,\n      L = s.length;\n  var i,\n      b = 0,\n      c,\n      x,\n      l = 0,\n      a,\n      r = '';\n  var A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  for (i = 0; i < 64; i++) {\n    e[A.charAt(i)] = i;\n  }\n\n  for (x = 0; x < L; x++) {\n    c = e[s.charAt(x)];\n    b = (b << 6) + c;\n    l += 6;\n\n    while (l >= 8) {\n      ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));\n    }\n  }\n\n  return r;\n}\n/**\n * @return {string}\n */\n\n\nfunction UserFromToken(token) {\n  var fragments = token.split('.');\n\n  if (fragments.length !== 3) {\n    return '';\n  }\n\n  var b64Payload = fragments[1];\n  var payload = decodeBase64(b64Payload);\n  var data = JSON.parse(payload);\n  return data.user_id;\n}\n\nfunction encodeBase64(s) {\n  if (typeof window !== 'undefined' && window.btoa) {\n    return window.btoa(s);\n  } else {\n    return Buffer.from(s.toString(), 'binary').toString('base64');\n  }\n}\n/**\n *\n * @param userId {string} the id of the user\n * @return {string}\n */\n\n\nfunction DevToken(userId) {\n  return ['eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9', //{\"alg\": \"HS256\", \"typ\": \"JWT\"}\n  encodeBase64(JSON.stringify({\n    user_id: userId\n  })), 'devtoken'].join('.');\n}\n/**\n *\n * @param body {string} the signed message\n * @param secret {string} the shared secret used to generate the signature (Stream API secret)\n * @param signature {string} the signature to validate\n * @return {boolean}\n */\n\n\nfunction CheckSignature(body, secret, signature) {\n  var key = new Buffer(secret, 'ascii');\n  var hash = crypto.createHmac('sha256', key).update(body).digest('hex');\n  return hash === signature;\n}\n\nvar http = null;\nvar https = null;\n\nfunction isReadableStream(obj) {\n  return _typeof(obj) === 'object' && _typeof(obj._read === 'function') && _typeof(obj._readableState === 'object');\n}\n\nvar StreamChat =\n/*#__PURE__*/\nfunction () {\n  function StreamChat(key, secretOrOptions, options) {\n    var _this = this;\n\n    _classCallCheck(this, StreamChat);\n\n    _defineProperty(this, \"_hasClientID\", function () {\n      var hasClient = !!_this.clientID;\n      return hasClient;\n    });\n\n    _defineProperty(this, \"dispatchEvent\", function (event) {\n      // client event handlers\n      _this._handleClientEvent(event); // channel event handlers\n\n\n      var cid = event.cid;\n      var channel = _this.activeChannels[cid];\n\n      if (channel) {\n        channel._handleChannelEvent(event);\n      }\n    });\n\n    _defineProperty(this, \"handleEvent\", function (messageEvent) {\n      // dispatch the event to the channel listeners\n      var jsonString = messageEvent.data;\n      var event = JSON.parse(jsonString);\n      event.received_at = new Date();\n\n      _this.dispatchEvent(event);\n    });\n\n    _defineProperty(this, \"recoverState\",\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var cids, lastMessageIDs, _arr, _i, c, lastMessage, lastMessageId;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              cids = Object.keys(_this.activeChannels || {});\n              lastMessageIDs = {};\n              _arr = Object.values(_this.activeChannels);\n\n              for (_i = 0; _i < _arr.length; _i++) {\n                c = _arr[_i];\n                lastMessage = c.lastMessage();\n                lastMessageId = void 0;\n\n                if (lastMessage) {\n                  lastMessageId = lastMessage.id;\n                }\n\n                lastMessageIDs[c.cid] = lastMessageId;\n              }\n\n              if (!cids.length) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return _this.queryChannels({\n                cid: {\n                  $in: cids\n                }\n              }, {\n                last_message_at: -1\n              }, {\n                limit: 30,\n                recovery: true,\n                last_message_ids: lastMessageIDs\n              });\n\n            case 7:\n              _this.dispatchEvent({\n                type: 'connection.recovered'\n              });\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    })));\n\n    _defineProperty(this, \"_isUsingServerAuth\", function () {\n      // returns if were in server side mode or not...\n      var serverAuth = !!_this.secret;\n      return serverAuth;\n    }); // set the key\n\n\n    this.key = key;\n    this.userToken = null;\n    this.secret = null;\n    this.listeners = {};\n    this.state = new ClientState(); // set the secret\n\n    if (secretOrOptions && secretOrOptions.indexOf) {\n      this.secret = secretOrOptions;\n    } // set the options... and figure out defaults...\n\n\n    options = options || secretOrOptions;\n\n    if (!options) {\n      options = {};\n    }\n\n    this.browser = typeof options.browser !== 'undefined' ? options.browser : typeof window !== 'undefined';\n    this.node = !this.browser;\n    var defaultOptions = {\n      timeout: 3000\n    };\n\n    if (this.node) {\n      var nodeOptions = {\n        httpAgent: new http.Agent({\n          keepAlive: 3000\n        }),\n        httpsAgent: new https.Agent({\n          keepAlive: 3000\n        })\n      };\n      this.options = _objectSpread({}, nodeOptions, defaultOptions, options);\n    } else {\n      this.options = _objectSpread({}, defaultOptions, options);\n      delete this.options.httpAgent;\n      delete this.options.httpsAgent;\n    }\n\n    this.setBaseURL('https://chat-us-east-1.stream-io-api.com');\n\n    if (typeof process !== 'undefined' && process.env.STREAM_LOCAL_TEST_RUN) {\n      this.setBaseURL('http://localhost:3030');\n    } // WS connection is initialized when setUser is called\n\n\n    this.wsConnection = null;\n    this.wsPromise = null; // keeps a reference to all the channels that are in use\n\n    this.activeChannels = {}; // mapping between channel groups and configs\n\n    this.configs = {};\n    this.anonymous = false;\n\n    this._startCleaning();\n  }\n\n  _createClass(StreamChat, [{\n    key: \"devToken\",\n    value: function devToken(userID) {\n      return DevToken(userID);\n    }\n  }, {\n    key: \"getAuthType\",\n    value: function getAuthType() {\n      return this.anonymous ? 'anonymous' : 'jwt';\n    }\n  }, {\n    key: \"setBaseURL\",\n    value: function setBaseURL(baseURL) {\n      this.baseURL = baseURL;\n      this.wsBaseURL = this.baseURL.replace('http', 'ws');\n    }\n  }, {\n    key: \"_setupConnection\",\n    value: function _setupConnection() {\n      this.UUID = uuidv4();\n      this.clientID = \"\".concat(this.userID, \"--\").concat(this.UUID);\n      this.connect();\n      return this.wsPromise;\n    }\n  }, {\n    key: \"setUser\",\n\n    /**\n     * setUser - Set the current user, this triggers a connection to the API\n     *\n     * @param {object} user Data about this user. IE {name: \"john\"}\n     * @param {string} userToken   Token\n     *\n     * @return {promise} Returns a promise that resolves when the connection is setup\n     */\n    value: function setUser(user, userToken) {\n      if (this.userID) {\n        throw new Error('Use client.disconnect() before trying to connect as a different user. setUser was called twice.');\n      } // we generate the client id client side\n\n\n      this.userID = user.id;\n\n      if (!this.userID) {\n        throw new Error('The \"id\" field on the user is missing');\n      }\n\n      this.userToken = userToken;\n\n      if (userToken == null && this.secret != null) {\n        this.userToken = this.createToken(this.userID);\n      }\n\n      if (this.userToken == null) {\n        throw new Error('both userToken and api secret are not provided');\n      }\n\n      var tokenUserId = UserFromToken(this.userToken);\n\n      if (userToken != null && (tokenUserId == null || tokenUserId === '' || tokenUserId !== user.id)) {\n        throw new Error('userToken does not have a user_id or is not matching with user.id');\n      }\n\n      this._setUser(user);\n\n      this.anonymous = false;\n      return this._setupConnection();\n    }\n  }, {\n    key: \"_setUser\",\n    value: function _setUser(user) {\n      // this one is used by the frontend\n      this.user = user; // this one is actually used for requests...\n\n      this._user = _objectSpread({}, user);\n    }\n    /**\n     * updateAppSettings - updates application settings\n     *\n     * @param {object} options App settings.\n     * \t\tIE: {\n      \t\t\t\"apn_config\": {\n    \t\t\t\t\"auth_type\": \"token\",\n    \t\t\t\t\"auth_key\": fs.readFileSync(\n    \t\t\t\t\t'./apn-push-auth-key.p8',\n    \t\t\t\t\t'utf-8',\n    \t\t\t\t),\n    \t\t\t\t\"key_id\": \"keyid\",\n    \t\t\t\t\"team_id\": \"teamid\", //either ALL these 3\n    \t\t\t\t\"notification_template\": \"notification handlebars template\",\n    \t\t\t\t\"bundle_id\": \"com.apple.your.app\",\n    \t\t\t\t\"development\": true\n    \t\t\t},\n    \t\t\t\"firebase_config\": {\n    \t\t\t\t\"api_key\": \"apiapiapi\",\n    \t\t\t\t\"notification_template\": \"notification handlebars template\"\n    \t\t\t},\n    \t\t\t\"webhook_url\": \"https://acme.com/my/awesome/webhook/\"\n    \t\t}\n     */\n\n  }, {\n    key: \"updateAppSettings\",\n    value: function () {\n      var _updateAppSettings = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(options) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (options.apn_config && options.apn_config.p12_cert) {\n                  options.apn_config.p12_cert = Buffer.from(options.apn_config.p12_cert).toString('base64');\n                }\n\n                _context2.next = 3;\n                return this.patch(this.baseURL + '/app', options);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updateAppSettings(_x) {\n        return _updateAppSettings.apply(this, arguments);\n      }\n\n      return updateAppSettings;\n    }()\n    /**\n     * getAppSettings - retrieves application settings\n     */\n\n  }, {\n    key: \"getAppSettings\",\n    value: function () {\n      var _getAppSettings = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.get(this.baseURL + '/app');\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getAppSettings() {\n        return _getAppSettings.apply(this, arguments);\n      }\n\n      return getAppSettings;\n    }()\n    /**\n     * disconnect - closes the WS connection\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      // remove the user specific fields\n      delete this.user;\n      delete this._user;\n      delete this.anonymous;\n      delete this.userID;\n      delete this.userToken;\n      this.connectionEstablishedCount = 0; // close the WS connection\n\n      if (this.wsConnection) {\n        this.wsConnection.disconnect();\n      }\n    }\n  }, {\n    key: \"setAnonymousUser\",\n    value: function setAnonymousUser() {\n      this.anonymous = true;\n      this.userID = uuidv4();\n\n      this._setUser({\n        id: this.userID,\n        anon: true\n      });\n\n      return this._setupConnection();\n    }\n    /**\n     * setGuestUser - Setup a temporary guest user\n     *\n     * @param {object} user Data about this user. IE {name: \"john\"}\n     *\n     * @return {promise} Returns a promise that resolves when the connection is setup\n     */\n\n  }, {\n    key: \"setGuestUser\",\n    value: function () {\n      var _setGuestUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(user) {\n        var response, _response$user, created_at, updated_at, last_active, online, guestUser;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this.anonymous = true;\n                _context4.prev = 1;\n                _context4.next = 4;\n                return this.post(this.baseURL + '/guest', {\n                  user: user\n                });\n\n              case 4:\n                response = _context4.sent;\n                _context4.next = 11;\n                break;\n\n              case 7:\n                _context4.prev = 7;\n                _context4.t0 = _context4[\"catch\"](1);\n                this.anonymous = false;\n                throw _context4.t0;\n\n              case 11:\n                this.anonymous = false;\n                _response$user = response.user, created_at = _response$user.created_at, updated_at = _response$user.updated_at, last_active = _response$user.last_active, online = _response$user.online, guestUser = _objectWithoutProperties(_response$user, [\"created_at\", \"updated_at\", \"last_active\", \"online\"]);\n                _context4.next = 15;\n                return this.setUser(guestUser, response.access_token);\n\n              case 15:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 7]]);\n      }));\n\n      function setGuestUser(_x2) {\n        return _setGuestUser.apply(this, arguments);\n      }\n\n      return setGuestUser;\n    }()\n    /**\n     * createToken - Creates a token to authenticate this user. This function is used server side.\n     * The resulting token should be passed to the client side when the users registers or logs in\n     *\n     * @param {string}   userID         The User ID\n     * @param {string}   exp            The expiration time for the token expressed in the number of seconds since the epoch\n     *\n     * @return {string} Returns a token\n     */\n\n  }, {\n    key: \"createToken\",\n    value: function createToken(userID, exp) {\n      var extra = {};\n\n      if (exp != null) {\n        extra.exp = exp;\n      }\n\n      return JWTUserToken(this.secret, userID, extra, {});\n    }\n    /**\n     * on - Listen to events on all channels and users your watching\n     *\n     * client.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n     * or\n     * client.on(event => {console.log(event.type)})\n     *\n     * @param {string} callbackOrString  The event type to listen for (optional)\n     * @param {function} callbackOrNothing The callback to call\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(callbackOrString, callbackOrNothing) {\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this.listeners[key].push(callback);\n    }\n    /**\n     * off - Remove the event handler\n     *\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(callbackOrString, callbackOrNothing) {\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this.listeners[key] = this.listeners[key].filter(function (value) {\n        return value !== callback;\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(url, params) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return axios.get(url, this._addClientParams(params));\n\n              case 3:\n                response = _context5.sent;\n                return _context5.abrupt(\"return\", this.handleResponse(response));\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](0);\n\n                if (!_context5.t0.response) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", this.handleResponse(_context5.t0.response));\n\n              case 13:\n                throw _context5.t0;\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 7]]);\n      }));\n\n      function get(_x3, _x4) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(url, data) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return axios.put(url, data, this._addClientParams());\n\n              case 3:\n                response = _context6.sent;\n                return _context6.abrupt(\"return\", this.handleResponse(response));\n\n              case 7:\n                _context6.prev = 7;\n                _context6.t0 = _context6[\"catch\"](0);\n\n                if (!_context6.t0.response) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", this.handleResponse(_context6.t0.response));\n\n              case 13:\n                throw _context6.t0;\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 7]]);\n      }));\n\n      function put(_x5, _x6) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(url, data) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return axios.post(url, data, this._addClientParams());\n\n              case 3:\n                response = _context7.sent;\n                return _context7.abrupt(\"return\", this.handleResponse(response));\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n\n                if (!_context7.t0.response) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this.handleResponse(_context7.t0.response));\n\n              case 13:\n                throw _context7.t0;\n\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 7]]);\n      }));\n\n      function post(_x7, _x8) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n  }, {\n    key: \"patch\",\n    value: function () {\n      var _patch = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(url, data) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return axios.patch(url, data, this._addClientParams());\n\n              case 3:\n                response = _context8.sent;\n                return _context8.abrupt(\"return\", this.handleResponse(response));\n\n              case 7:\n                _context8.prev = 7;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!_context8.t0.response) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.handleResponse(_context8.t0.response));\n\n              case 13:\n                throw _context8.t0;\n\n              case 14:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 7]]);\n      }));\n\n      function patch(_x9, _x10) {\n        return _patch.apply(this, arguments);\n      }\n\n      return patch;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(url, params) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return axios.delete(url, this._addClientParams(params));\n\n              case 3:\n                response = _context9.sent;\n                return _context9.abrupt(\"return\", this.handleResponse(response));\n\n              case 7:\n                _context9.prev = 7;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                if (!_context9.t0.response) {\n                  _context9.next = 13;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this.handleResponse(_context9.t0.response));\n\n              case 13:\n                throw _context9.t0;\n\n              case 14:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 7]]);\n      }));\n\n      function _delete(_x11, _x12) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }, {\n    key: \"sendFile\",\n    value: function () {\n      var _sendFile = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(url, uri, name, contentType, user) {\n        var data, fileField, params, response;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                data = new FormData();\n                params = this._addClientParams();\n\n                if (isReadableStream(uri)) {\n                  fileField = uri;\n                } else {\n                  fileField = {\n                    uri: uri,\n                    name: name || uri.split('/').reverse()[0]\n                  };\n\n                  if (contentType != null) {\n                    fileField.type = contentType;\n                  }\n                }\n\n                if (user != null) {\n                  data.append('user', JSON.stringify(user));\n                }\n\n                data.append('file', fileField);\n                _context10.next = 7;\n                return fetch(\"\".concat(url, \"?api_key=\").concat(this.key), {\n                  method: 'post',\n                  body: data,\n                  headers: new Headers({\n                    Authorization: params.headers.Authorization,\n                    'stream-auth-type': this.getAuthType()\n                  })\n                });\n\n              case 7:\n                response = _context10.sent;\n                _context10.next = 10;\n                return response.json();\n\n              case 10:\n                response.data = _context10.sent;\n                return _context10.abrupt(\"return\", this.handleResponse(response));\n\n              case 12:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function sendFile(_x13, _x14, _x15, _x16, _x17) {\n        return _sendFile.apply(this, arguments);\n      }\n\n      return sendFile;\n    }()\n  }, {\n    key: \"errorFromResponse\",\n    value: function errorFromResponse(response) {\n      var err;\n      err = new Error(\"StreamChat error HTTP code: \".concat(response.status));\n\n      if (response.data && response.data.code) {\n        err = new Error(\"StreamChat error code \".concat(response.data.code, \": \").concat(response.data.message));\n        err.code = response.data.code;\n      }\n\n      err.response = response;\n      err.status = response.status;\n      return err;\n    }\n  }, {\n    key: \"handleResponse\",\n    value: function handleResponse(response) {\n      var data = response.data;\n\n      if ((response.status + '')[0] !== '2') {\n        throw this.errorFromResponse(response);\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_handleClientEvent\",\n    value: function _handleClientEvent(event) {\n      var client = this; // update the client.state with any changes to users\n\n      if (event.type === 'user.presence.changed' || event.type === 'user.updated') {\n        client.state.updateUser(event.user);\n      }\n\n      if (event.type === 'health.check') {\n        if (event.me) {\n          client.user = event.me;\n          client.state.updateUser(event.me);\n        }\n      }\n\n      if (event.type === 'notification.message_new') {\n        this.configs[event.channel.type] = event.channel.config;\n      } // gather and call the listeners\n\n\n      var listeners = [];\n\n      if (client.listeners.all) {\n        listeners.push.apply(listeners, _toConsumableArray(client.listeners.all));\n      }\n\n      if (client.listeners[event.type]) {\n        listeners.push.apply(listeners, _toConsumableArray(client.listeners[event.type]));\n      } // call the event and send it to the listeners\n\n\n      for (var _i2 = 0; _i2 < listeners.length; _i2++) {\n        var listener = listeners[_i2];\n        listener(event);\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.connecting = true;\n      var client = this;\n      this.failures = 0;\n\n      if (client.userID == null) {\n        throw Error('Call setUser or setAnonymousUser before starting the connection');\n      }\n\n      var params = {\n        client_id: client.clientID,\n        user_id: client.userID,\n        user_details: client._user,\n        user_token: client.userToken\n      };\n      var qs = encodeURIComponent(JSON.stringify(params));\n\n      if (qs.length > 1900) {\n        throw Error('User object is too large');\n      }\n\n      var token = '';\n\n      if (this.anonymous === false) {\n        token = this.userToken !== null ? this.userToken : JWTServerToken(this.secret);\n      }\n\n      var authType = this.getAuthType();\n      client.wsURL = \"\".concat(client.wsBaseURL, \"/connect?json=\").concat(qs, \"&api_key=\").concat(this.key, \"&authorization=\").concat(token, \"&stream-auth-type=\").concat(authType); // The StableWSConnection handles all the reconnection logic.\n\n      this.wsConnection = new StableWSConnection({\n        wsURL: client.wsURL,\n        clientID: this.clientID,\n        userID: this.userID,\n        recoverCallback: this.recoverState,\n        messageCallback: this.handleEvent,\n        eventCallback: this.dispatchEvent\n      });\n      this.wsPromise = this.wsConnection.connect();\n      return this.wsPromise;\n    }\n    /**\n     * queryUsers - Query users and watch user presence\n     *\n     * @param {object} filterConditions MongoDB style filter conditions\n     * @param {object} sort             Sort options, for instance {last_active: -1}\n     * @param {object} options          Option object, {presence: true}\n     *\n     * @return {object} User Query Response\n     */\n\n  }, {\n    key: \"queryUsers\",\n    value: function () {\n      var _queryUsers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(filterConditions, sort, options) {\n        var sortFields, _arr2, _i3, _arr2$_i, k, v, defaultOptions, data;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!sort) {\n                  sort = {};\n                }\n\n                if (!options) {\n                  options = {};\n                }\n\n                sortFields = [];\n                _arr2 = Object.entries(sort);\n\n                for (_i3 = 0; _i3 < _arr2.length; _i3++) {\n                  _arr2$_i = _slicedToArray(_arr2[_i3], 2), k = _arr2$_i[0], v = _arr2$_i[1];\n                  sortFields.push({\n                    field: k,\n                    direction: v\n                  });\n                }\n\n                defaultOptions = {\n                  presence: true\n                };\n\n                if (!this._hasClientID()) {\n                  defaultOptions.presence = false;\n                } // Make sure we wait for the connect promise if there is a pending one\n\n\n                _context11.next = 9;\n                return Promise.resolve(this.wsPromise);\n\n              case 9:\n                _context11.next = 11;\n                return this.get(this.baseURL + '/users', {\n                  payload: _objectSpread({\n                    filter_conditions: filterConditions,\n                    sort: sortFields\n                  }, defaultOptions, options)\n                });\n\n              case 11:\n                data = _context11.sent;\n                return _context11.abrupt(\"return\", data);\n\n              case 13:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function queryUsers(_x18, _x19, _x20) {\n        return _queryUsers.apply(this, arguments);\n      }\n\n      return queryUsers;\n    }()\n  }, {\n    key: \"queryChannels\",\n    value: function () {\n      var _queryChannels = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12(filterConditions) {\n        var sort,\n            options,\n            sortFields,\n            _arr3,\n            _i4,\n            _arr3$_i,\n            k,\n            v,\n            defaultOptions,\n            payload,\n            data,\n            channels,\n            _iteratorNormalCompletion,\n            _didIteratorError,\n            _iteratorError,\n            _iterator,\n            _step,\n            channelState,\n            _iteratorNormalCompletion2,\n            _didIteratorError2,\n            _iteratorError2,\n            _iterator2,\n            _step2,\n            _channelState,\n            c,\n            _args12 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                sort = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};\n                options = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {};\n                sortFields = [];\n                _arr3 = Object.entries(sort);\n\n                for (_i4 = 0; _i4 < _arr3.length; _i4++) {\n                  _arr3$_i = _slicedToArray(_arr3[_i4], 2), k = _arr3$_i[0], v = _arr3$_i[1];\n                  sortFields.push({\n                    field: k,\n                    direction: v\n                  });\n                }\n\n                defaultOptions = {\n                  state: true,\n                  watch: true,\n                  presence: false\n                };\n\n                if (!this._hasClientID()) {\n                  defaultOptions.watch = false;\n                } // Return a list of channels\n\n\n                payload = _objectSpread({\n                  filter_conditions: filterConditions,\n                  sort: sortFields,\n                  user_details: this._user\n                }, defaultOptions, options); // Make sure we wait for the connect promise if there is a pending one\n\n                _context12.next = 10;\n                return Promise.resolve(this.wsPromise);\n\n              case 10:\n                _context12.next = 12;\n                return this.get(this.baseURL + '/channels', {\n                  payload: payload\n                });\n\n              case 12:\n                data = _context12.sent;\n                channels = []; // update our cache of the configs\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context12.prev = 17;\n\n                for (_iterator = data.channels[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  channelState = _step.value;\n\n                  this._addChannelConfig(channelState);\n                }\n\n                _context12.next = 25;\n                break;\n\n              case 21:\n                _context12.prev = 21;\n                _context12.t0 = _context12[\"catch\"](17);\n                _didIteratorError = true;\n                _iteratorError = _context12.t0;\n\n              case 25:\n                _context12.prev = 25;\n                _context12.prev = 26;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 28:\n                _context12.prev = 28;\n\n                if (!_didIteratorError) {\n                  _context12.next = 31;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 31:\n                return _context12.finish(28);\n\n              case 32:\n                return _context12.finish(25);\n\n              case 33:\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _iteratorError2 = undefined;\n                _context12.prev = 36;\n\n                for (_iterator2 = data.channels[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  _channelState = _step2.value;\n                  c = this.channel(_channelState.channel.type, _channelState.channel.id);\n                  c.data = _channelState.channel;\n                  c.initialized = true;\n\n                  c._initializeState(_channelState);\n\n                  channels.push(c);\n                }\n\n                _context12.next = 44;\n                break;\n\n              case 40:\n                _context12.prev = 40;\n                _context12.t1 = _context12[\"catch\"](36);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context12.t1;\n\n              case 44:\n                _context12.prev = 44;\n                _context12.prev = 45;\n\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n\n              case 47:\n                _context12.prev = 47;\n\n                if (!_didIteratorError2) {\n                  _context12.next = 50;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 50:\n                return _context12.finish(47);\n\n              case 51:\n                return _context12.finish(44);\n\n              case 52:\n                return _context12.abrupt(\"return\", channels);\n\n              case 53:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[17, 21, 25, 33], [26,, 28, 32], [36, 40, 44, 52], [45,, 47, 51]]);\n      }));\n\n      function queryChannels(_x21) {\n        return _queryChannels.apply(this, arguments);\n      }\n\n      return queryChannels;\n    }()\n  }, {\n    key: \"search\",\n    value: function () {\n      var _search = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(filterConditions, query) {\n        var options,\n            payload,\n            data,\n            _args13 = arguments;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                options = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : {}; // Return a list of channels\n\n                payload = _objectSpread({\n                  filter_conditions: filterConditions,\n                  query: query\n                }, options); // Make sure we wait for the connect promise if there is a pending one\n\n                _context13.next = 4;\n                return Promise.resolve(this.wsPromise);\n\n              case 4:\n                _context13.next = 6;\n                return this.get(this.baseURL + '/search', {\n                  payload: payload\n                });\n\n              case 6:\n                data = _context13.sent;\n                return _context13.abrupt(\"return\", data);\n\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function search(_x22, _x23) {\n        return _search.apply(this, arguments);\n      }\n\n      return search;\n    }()\n    /**\n     * addDevice - Adds a push device for a user.\n     *\n     * @param {string} id the device id\n     * @param {string} push_provider the push provider (apn or firebase)\n     * @param {string} [userID] the user id (defaults to current user)\n     *\n     */\n\n  }, {\n    key: \"addDevice\",\n    value: function () {\n      var _addDevice = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14(id, push_provider) {\n        var userID,\n            _args14 = arguments;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                userID = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : null;\n                _context14.next = 3;\n                return this.post(this.baseURL + '/devices', _objectSpread({\n                  id: id,\n                  push_provider: push_provider\n                }, userID != null ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context14.abrupt(\"return\", _context14.sent);\n\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function addDevice(_x24, _x25) {\n        return _addDevice.apply(this, arguments);\n      }\n\n      return addDevice;\n    }()\n    /**\n     * getDevices - Returns the devices associated with a current user\n     *\n     * @param {string} [userID] User ID. Only works on serversidex\n     *\n     * @return {devices} Array of devices\n     */\n\n  }, {\n    key: \"getDevices\",\n    value: function () {\n      var _getDevices = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee15(userID) {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.get(this.baseURL + '/devices', userID ? {\n                  user_id: userID\n                } : {});\n\n              case 2:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 3:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getDevices(_x26) {\n        return _getDevices.apply(this, arguments);\n      }\n\n      return getDevices;\n    }()\n    /**\n     * removeDevice - Removes the device with the given id. Clientside users can only delete their own devices\n     *\n     * @param {string} id The device id\n     * @param {string} [userID] The user id. Only specify this for serverside requests\n     *\n     */\n\n  }, {\n    key: \"removeDevice\",\n    value: function () {\n      var _removeDevice = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(id) {\n        var userID,\n            _args16 = arguments;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                userID = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : null;\n                _context16.next = 3;\n                return this.delete(this.baseURL + '/devices', _objectSpread({\n                  id: id\n                }, userID ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context16.abrupt(\"return\", _context16.sent);\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function removeDevice(_x27) {\n        return _removeDevice.apply(this, arguments);\n      }\n\n      return removeDevice;\n    }()\n  }, {\n    key: \"_addChannelConfig\",\n    value: function _addChannelConfig(channelState) {\n      this.configs[channelState.channel.type] = channelState.channel.config;\n    }\n    /**\n     * channel - Returns a new channel with the given type and id\n     *\n     * @param {string} channelType The channel type\n     * @param {string} channelID   The channel data\n     * @param {object} [custom]      Custom data to attach to the channel\n     *\n     * @return {channel} The channel object, initialize it using channel.watch()\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(channelType, channelID) {\n      var custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!this.userID && !this._isUsingServerAuth()) {\n        throw Error('Call setUser or setAnonymousUser before creating a channel');\n      }\n\n      if (~channelType.indexOf(':')) {\n        throw Error(\"Invalid channel group \".concat(channelType, \", cant contain the : character\"));\n      }\n\n      if (typeof channelID === 'string') {\n        channelID = channelID + '';\n\n        if (~channelID.indexOf(':')) {\n          throw Error(\"Invalid channel id \".concat(channelID, \", cant contain the : character\"));\n        }\n      } else {\n        // support the 2 param init method\n        custom = channelID || {};\n        channelID = undefined;\n      } // there are two ways of solving this,\n      // a. only allow 1 channel object per cid\n      // b. broadcast events to all channels\n      // the first option seems less likely to trip up devs\n\n\n      var channel;\n\n      if (channelID) {\n        var cid = \"\".concat(channelType, \":\").concat(channelID);\n\n        if (cid in this.activeChannels) {\n          channel = this.activeChannels[cid];\n\n          if (Object.keys(custom).length > 0) {\n            channel.data = custom;\n            channel._data = custom;\n          }\n        } else {\n          channel = new Channel(this, channelType, channelID, custom);\n          this.activeChannels[channel.cid] = channel;\n        }\n      } else {\n        channel = new Channel(this, channelType, undefined, custom);\n      }\n\n      return channel;\n    }\n    /**\n     * updateUser - Update or Create the given user object\n     *\n     * @param {object} A user object, the only required field is the user id. IE {id: \"myuser\"} is valid\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function () {\n      var _updateUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17(userObject) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.updateUsers([userObject]);\n\n              case 2:\n                return _context17.abrupt(\"return\", _context17.sent);\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function updateUser(_x28) {\n        return _updateUser.apply(this, arguments);\n      }\n\n      return updateUser;\n    }()\n    /**\n     * updateUsers - Batch update the list of users\n     *\n     * @param {array} A list of users\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"updateUsers\",\n    value: function () {\n      var _updateUsers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(users) {\n        var userMap, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, userObject;\n\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                userMap = {};\n                _iteratorNormalCompletion3 = true;\n                _didIteratorError3 = false;\n                _iteratorError3 = undefined;\n                _context18.prev = 4;\n                _iterator3 = users[Symbol.iterator]();\n\n              case 6:\n                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                  _context18.next = 14;\n                  break;\n                }\n\n                userObject = _step3.value;\n\n                if (userObject.id) {\n                  _context18.next = 10;\n                  break;\n                }\n\n                throw Error('User ID is required when updating a user');\n\n              case 10:\n                userMap[userObject.id] = userObject;\n\n              case 11:\n                _iteratorNormalCompletion3 = true;\n                _context18.next = 6;\n                break;\n\n              case 14:\n                _context18.next = 20;\n                break;\n\n              case 16:\n                _context18.prev = 16;\n                _context18.t0 = _context18[\"catch\"](4);\n                _didIteratorError3 = true;\n                _iteratorError3 = _context18.t0;\n\n              case 20:\n                _context18.prev = 20;\n                _context18.prev = 21;\n\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n\n              case 23:\n                _context18.prev = 23;\n\n                if (!_didIteratorError3) {\n                  _context18.next = 26;\n                  break;\n                }\n\n                throw _iteratorError3;\n\n              case 26:\n                return _context18.finish(23);\n\n              case 27:\n                return _context18.finish(20);\n\n              case 28:\n                _context18.next = 30;\n                return this.post(this.baseURL + '/users', {\n                  users: userMap\n                });\n\n              case 30:\n                return _context18.abrupt(\"return\", _context18.sent);\n\n              case 31:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[4, 16, 20, 28], [21,, 23, 27]]);\n      }));\n\n      function updateUsers(_x29) {\n        return _updateUsers.apply(this, arguments);\n      }\n\n      return updateUsers;\n    }()\n    /** banUser - bans a user from all channels\n     *\n     * @param targetUserID\n     * @param options\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"banUser\",\n    value: function () {\n      var _banUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee19(targetUserID, options) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.post(this.baseURL + '/moderation/ban', _objectSpread({\n                  target_user_id: targetUserID\n                }, options));\n\n              case 2:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function banUser(_x30, _x31) {\n        return _banUser.apply(this, arguments);\n      }\n\n      return banUser;\n    }()\n    /** unbanUser - revoke global ban for a user\n     *\n     * @param targetUserID\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"unbanUser\",\n    value: function () {\n      var _unbanUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee20(targetUserID, options) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return this.delete(this.baseURL + '/moderation/ban', _objectSpread({\n                  target_user_id: targetUserID\n                }, options));\n\n              case 2:\n                return _context20.abrupt(\"return\", _context20.sent);\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function unbanUser(_x32, _x33) {\n        return _unbanUser.apply(this, arguments);\n      }\n\n      return unbanUser;\n    }()\n    /** muteUser - mutes a user\n     *\n     * @param targetID\n     * @param [userID] Only used with serverside auth\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"muteUser\",\n    value: function () {\n      var _muteUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee21(targetID) {\n        var userID,\n            _args21 = arguments;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                userID = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : null;\n                _context21.next = 3;\n                return this.post(this.baseURL + '/moderation/mute', _objectSpread({\n                  target_id: targetID\n                }, userID ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 4:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function muteUser(_x34) {\n        return _muteUser.apply(this, arguments);\n      }\n\n      return muteUser;\n    }()\n    /** unmuteUser - unmutes a user\n     *\n     * @param targetID\n     * @param [userID] Only used with serverside auth\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"unmuteUser\",\n    value: function () {\n      var _unmuteUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee22(targetID) {\n        var userID,\n            _args22 = arguments;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                userID = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : null;\n                _context22.next = 3;\n                return this.post(this.baseURL + '/moderation/unmute', _objectSpread({\n                  target_id: targetID\n                }, userID ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context22.abrupt(\"return\", _context22.sent);\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function unmuteUser(_x35) {\n        return _unmuteUser.apply(this, arguments);\n      }\n\n      return unmuteUser;\n    }()\n  }, {\n    key: \"flagMessage\",\n    value: function () {\n      var _flagMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee23(messageID) {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.post(this.baseURL + '/moderation/flag', {\n                  target_message_id: messageID\n                });\n\n              case 2:\n                return _context23.abrupt(\"return\", _context23.sent);\n\n              case 3:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function flagMessage(_x36) {\n        return _flagMessage.apply(this, arguments);\n      }\n\n      return flagMessage;\n    }()\n  }, {\n    key: \"flagUser\",\n    value: function () {\n      var _flagUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee24(userID) {\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.post(this.baseURL + '/moderation/flag', {\n                  target_user_id: userID\n                });\n\n              case 2:\n                return _context24.abrupt(\"return\", _context24.sent);\n\n              case 3:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function flagUser(_x37) {\n        return _flagUser.apply(this, arguments);\n      }\n\n      return flagUser;\n    }()\n  }, {\n    key: \"unflagMessage\",\n    value: function () {\n      var _unflagMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee25(messageID) {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return this.post(this.baseURL + '/moderation/unflag', {\n                  target_message_id: messageID\n                });\n\n              case 2:\n                return _context25.abrupt(\"return\", _context25.sent);\n\n              case 3:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function unflagMessage(_x38) {\n        return _unflagMessage.apply(this, arguments);\n      }\n\n      return unflagMessage;\n    }()\n  }, {\n    key: \"unflagUser\",\n    value: function () {\n      var _unflagUser = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee26(userID) {\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this.post(this.baseURL + '/moderation/unflag', {\n                  target_user_id: userID\n                });\n\n              case 2:\n                return _context26.abrupt(\"return\", _context26.sent);\n\n              case 3:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function unflagUser(_x39) {\n        return _unflagUser.apply(this, arguments);\n      }\n\n      return unflagUser;\n    }()\n  }, {\n    key: \"createChannelType\",\n    value: function createChannelType(data) {\n      var channelData = _extends({}, {\n        commands: ['all']\n      }, data);\n\n      return this.post(this.baseURL + '/channeltypes', channelData);\n    }\n  }, {\n    key: \"getChannelType\",\n    value: function getChannelType(channelType) {\n      return this.get(this.baseURL + \"/channeltypes/\".concat(channelType));\n    }\n  }, {\n    key: \"updateChannelType\",\n    value: function updateChannelType(channelType, data) {\n      return this.put(this.baseURL + \"/channeltypes/\".concat(channelType), data);\n    }\n  }, {\n    key: \"deleteChannelType\",\n    value: function deleteChannelType(channelType) {\n      return this.delete(this.baseURL + \"/channeltypes/\".concat(channelType));\n    }\n  }, {\n    key: \"listChannelTypes\",\n    value: function listChannelTypes() {\n      return this.get(this.baseURL + \"/channeltypes\");\n    }\n    /**\n     * updateMessage - Update the given message\n     *\n     * @param {object} message object, id needs to be specified\n     *\n     * @return {object} Response that includes the message\n     */\n\n  }, {\n    key: \"updateMessage\",\n    value: function () {\n      var _updateMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee27(message, userId) {\n        var clonedMessage, reservedMessageFields;\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                if (message.id) {\n                  _context27.next = 2;\n                  break;\n                }\n\n                throw Error('Please specify the message id when calling updateMesssage');\n\n              case 2:\n                clonedMessage = _extends({}, message);\n                delete clonedMessage.id;\n                reservedMessageFields = ['latest_reactions', 'own_reactions', 'reply_count', 'created_at', 'updated_at', 'html', 'command', 'type', 'user'];\n                reservedMessageFields.forEach(function (item) {\n                  if (clonedMessage[item] != null) {\n                    delete clonedMessage[item];\n                  }\n                });\n\n                if (userId != null) {\n                  clonedMessage.user = {\n                    id: userId\n                  };\n                }\n\n                _context27.next = 9;\n                return this.post(this.baseURL + \"/messages/\".concat(message.id), {\n                  message: clonedMessage\n                });\n\n              case 9:\n                return _context27.abrupt(\"return\", _context27.sent);\n\n              case 10:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function updateMessage(_x40, _x41) {\n        return _updateMessage.apply(this, arguments);\n      }\n\n      return updateMessage;\n    }()\n  }, {\n    key: \"deleteMessage\",\n    value: function () {\n      var _deleteMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee28(messageID) {\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this.delete(this.baseURL + \"/messages/\".concat(messageID));\n\n              case 2:\n                return _context28.abrupt(\"return\", _context28.sent);\n\n              case 3:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function deleteMessage(_x42) {\n        return _deleteMessage.apply(this, arguments);\n      }\n\n      return deleteMessage;\n    }()\n  }, {\n    key: \"_userAgent\",\n    value: function _userAgent() {\n      var description = this.node ? 'node' : 'browser';\n      var version = '1.0';\n      return \"stream-chat-\".concat(description, \"-\").concat(version);\n    }\n    /**\n     * _isUsingServerAuth - Returns true if we're using server side auth\n     */\n\n  }, {\n    key: \"_addClientParams\",\n    value: function _addClientParams() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var token = '';\n\n      if (this.secret === null && this.userToken === null && this.anonymous === false) {\n        throw new Error('Both secret and user tokens are not set, did you forget to call client.setUser?');\n      }\n\n      if (this.anonymous === false) {\n        token = this.userToken !== null ? this.userToken : JWTServerToken(this.secret);\n      }\n\n      return _objectSpread({}, this.options, {\n        params: _objectSpread({\n          user_id: this.userID\n        }, params, {\n          api_key: this.key,\n          client_id: this.clientID\n        }),\n        headers: {\n          Authorization: token,\n          'stream-auth-type': this.getAuthType()\n        }\n      });\n    }\n  }, {\n    key: \"_startCleaning\",\n    value: function _startCleaning() {\n      var that = this;\n      this.cleaningIntervalRef = setInterval(function () {\n        // call clean on the channel, used for calling the stop.typing event etc.\n        var _arr4 = Object.values(that.activeChannels);\n\n        for (var _i5 = 0; _i5 < _arr4.length; _i5++) {\n          var channel = _arr4[_i5];\n          channel.clean();\n        }\n      }, 500);\n    }\n  }, {\n    key: \"verifyWebhook\",\n    value: function verifyWebhook(requestBody, xSignature) {\n      return CheckSignature(requestBody, this.secret, xSignature);\n    }\n  }]);\n\n  return StreamChat;\n}();\n\nexport { StreamChat, logChatPromiseExecution };","map":null,"metadata":{},"sourceType":"module"}