{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _propTypes = require('prop-types');\n\nvar _theming = require('theming');\n\nvar _filterProps = require('./utils/filterProps');\n\nvar _filterProps2 = _interopRequireDefault(_filterProps);\n\nvar _composeClasses = require('./utils/composeClasses');\n\nvar _composeClasses2 = _interopRequireDefault(_composeClasses);\n\nvar _generateTagName = require('./utils/generateTagName');\n\nvar _generateTagName2 = _interopRequireDefault(_generateTagName);\n\nvar _getSeparatedStyles2 = require('./utils/getSeparatedStyles');\n\nvar _getSeparatedStyles3 = _interopRequireDefault(_getSeparatedStyles2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar getElementName = function getElementName(element) {\n  return element.displayName || element.name || 'StyledElement';\n};\n\nvar getParamsByElement = function getParamsByElement(element) {\n  if (typeof element === 'string') return {\n    tagName: element\n  };\n  if (element.tagName) return element;\n  return {\n    tagName: getElementName(element),\n    reactComponent: element\n  };\n};\n\nvar styled = function styled(_ref) {\n  var element = _ref.element,\n      ownStyle = _ref.ownStyle,\n      mountSheet = _ref.mountSheet,\n      jss = _ref.jss;\n\n  var _getParamsByElement = getParamsByElement(element),\n      _getParamsByElement$s = _getParamsByElement.style,\n      style = _getParamsByElement$s === undefined ? [] : _getParamsByElement$s,\n      tagName = _getParamsByElement.tagName,\n      reactComponent = _getParamsByElement.reactComponent;\n\n  var elementStyle = style.concat(ownStyle);\n\n  var _getSeparatedStyles = _getSeparatedStyles3.default.apply(undefined, _toConsumableArray(elementStyle)),\n      dynamicStyle = _getSeparatedStyles.dynamicStyle,\n      staticStyle = _getSeparatedStyles.staticStyle;\n\n  var staticTagName = staticStyle && (0, _generateTagName2.default)(tagName);\n  var isFunctionStyle = typeof dynamicStyle === 'function';\n  var availableDynamicTagNames = [];\n  var classMap = {};\n  var staticClassName = void 0;\n\n  var StyledElement = function (_Component) {\n    _inherits(StyledElement, _Component); // If the base component is a React component (and thus neither an intrinsic tag or a\n    // styled element), make sure to keep a reference to the component around. Otherwise deeply\n    // nested styled elements won't render the base component correctly.\n\n\n    function StyledElement(props, context) {\n      _classCallCheck(this, StyledElement);\n\n      var _this = _possibleConstructorReturn(this, (StyledElement.__proto__ || Object.getPrototypeOf(StyledElement)).call(this, props, context));\n\n      _this.setTheme = function (theme) {\n        return _this.setState({\n          theme: theme\n        });\n      };\n\n      _this.dynamicTagName = '';\n      _this.staticClassName = '';\n\n      if (!_this.dynamicTagName && dynamicStyle) {\n        _this.dynamicTagName = availableDynamicTagNames.pop() || (0, _generateTagName2.default)(tagName);\n      }\n\n      _this.state = {};\n\n      if (context[_theming.channel]) {\n        _this.state.theme = _theming.themeListener.initial(context);\n      }\n\n      _this.staticClassName = staticClassName;\n      return _this;\n    }\n\n    _createClass(StyledElement, [{\n      key: 'componentWillMount',\n      value: function componentWillMount() {\n        this.sheet = this.sheet || mountSheet();\n        var rulesIndex = this.sheet.rules.index;\n        var rulesTotal = rulesIndex.length;\n\n        if (staticStyle && !this.sheet.getRule(staticTagName)) {\n          this.sheet.addRule(staticTagName, staticStyle);\n        }\n\n        if (!dynamicStyle) return;\n\n        if (!this.sheet.getRule(this.dynamicTagName)) {\n          this.sheet.addRule(this.dynamicTagName, dynamicStyle);\n        }\n\n        classMap[this.dynamicTagName] = classMap[this.dynamicTagName] || rulesIndex.slice(rulesTotal);\n        this.updateSheet(this.props, this.state);\n      }\n    }, {\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.state.theme) {\n          this.subscriptionId = _theming.themeListener.subscribe(this.context, this.setTheme);\n        }\n      }\n    }, {\n      key: 'componentWillUpdate',\n      value: function componentWillUpdate(nextProps, nextState) {\n        if (dynamicStyle) this.updateSheet(nextProps, nextState);\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        availableDynamicTagNames.push(this.dynamicTagName);\n\n        if (this.subscriptionId) {\n          _theming.themeListener.unsubscribe(this.context, this.subscriptionId);\n        }\n      }\n    }, {\n      key: 'updateSheet',\n      value: function updateSheet(props, state) {\n        var rule = void 0;\n        var ruleIndex = 0;\n        var styleProps = state.theme ? Object.assign({}, state, props) : props; // nested styles become to flatten rules, so we need to update each nested rule\n\n        for (ruleIndex; ruleIndex < classMap[this.dynamicTagName].length; ruleIndex++) {\n          rule = classMap[this.dynamicTagName][ruleIndex];\n\n          if (isFunctionStyle) {\n            this.sheet.update(rule.key, styleProps);\n          } else {\n            this.sheet.update(rule.key, styleProps);\n          }\n        }\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _props = this.props,\n            children = _props.children,\n            className = _props.className,\n            attrs = _objectWithoutProperties(_props, ['children', 'className']);\n\n        var props = reactComponent ? attrs : (0, _filterProps2.default)(tagName, attrs);\n        var tagClass = (0, _composeClasses2.default)([this.staticClassName, staticTagName && this.sheet.classes[staticTagName], this.dynamicTagName && this.sheet.classes[this.dynamicTagName], className]);\n        return (0, _react.createElement)(reactComponent || tagName, Object.assign({}, props, {\n          className: tagClass\n        }), children);\n      }\n    }]);\n\n    return StyledElement;\n  }(_react.Component); // $FlowIgnore\n\n\n  StyledElement.tagName = tagName;\n  StyledElement.style = elementStyle;\n  StyledElement.reactComponent = reactComponent;\n  StyledElement.contextTypes = _defineProperty({}, _theming.channel, _propTypes.object);\n\n  StyledElement.valueOf = function () {\n    if (!staticClassName) {\n      staticClassName = '' + jss.generateClassName({\n        key: (0, _generateTagName2.default)('static')\n      });\n    }\n\n    return '.' + staticClassName;\n  }; // $FlowIgnore\n\n\n  StyledElement.toString = StyledElement.valueOf;\n  return StyledElement;\n};\n\nexports.default = styled;","map":null,"metadata":{},"sourceType":"script"}