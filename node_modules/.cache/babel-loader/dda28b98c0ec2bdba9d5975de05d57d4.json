{"ast":null,"code":"/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/react-select\n*/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _reactInputAutosize = require('react-input-autosize');\n\nvar _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _utilsDefaultArrowRenderer = require('./utils/defaultArrowRenderer');\n\nvar _utilsDefaultArrowRenderer2 = _interopRequireDefault(_utilsDefaultArrowRenderer);\n\nvar _utilsDefaultFilterOptions = require('./utils/defaultFilterOptions');\n\nvar _utilsDefaultFilterOptions2 = _interopRequireDefault(_utilsDefaultFilterOptions);\n\nvar _utilsDefaultMenuRenderer = require('./utils/defaultMenuRenderer');\n\nvar _utilsDefaultMenuRenderer2 = _interopRequireDefault(_utilsDefaultMenuRenderer);\n\nvar _utilsDefaultClearRenderer = require('./utils/defaultClearRenderer');\n\nvar _utilsDefaultClearRenderer2 = _interopRequireDefault(_utilsDefaultClearRenderer);\n\nvar _utilsStripDiacritics = require('./utils/stripDiacritics');\n\nvar _utilsStripDiacritics2 = _interopRequireDefault(_utilsStripDiacritics);\n\nvar _Async = require('./Async');\n\nvar _Async2 = _interopRequireDefault(_Async);\n\nvar _AsyncCreatable = require('./AsyncCreatable');\n\nvar _AsyncCreatable2 = _interopRequireDefault(_AsyncCreatable);\n\nvar _Creatable = require('./Creatable');\n\nvar _Creatable2 = _interopRequireDefault(_Creatable);\n\nvar _Dropdown = require('./Dropdown');\n\nvar _Dropdown2 = _interopRequireDefault(_Dropdown);\n\nvar _Option = require('./Option');\n\nvar _Option2 = _interopRequireDefault(_Option);\n\nvar _OptionGroup = require('./OptionGroup');\n\nvar _OptionGroup2 = _interopRequireDefault(_OptionGroup);\n\nvar _Value = require('./Value');\n\nvar _Value2 = _interopRequireDefault(_Value);\n\nfunction clone(obj) {\n  var copy = {};\n\n  for (var attr in obj) {\n    if (obj.hasOwnProperty(attr)) {\n      copy[attr] = obj[attr];\n    }\n\n    ;\n  }\n\n  return copy;\n}\n\nfunction isGroup(option) {\n  return option && Array.isArray(option.options);\n}\n\nfunction stringifyValue(value) {\n  var valueType = typeof value;\n\n  if (valueType === 'string') {\n    return value;\n  } else if (valueType === 'object') {\n    return JSON.stringify(value);\n  } else if (valueType === 'number' || valueType === 'boolean') {\n    return String(value);\n  } else {\n    return '';\n  }\n}\n\nvar stringOrNode = _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.node]);\n\nvar instanceId = 1;\nvar invalidOptions = {};\n\nvar Select = _react2['default'].createClass({\n  displayName: 'Select',\n  propTypes: {\n    addLabelText: _react2['default'].PropTypes.string,\n    // placeholder displayed when you want to add a label on a multi-value input\n    'aria-describedby': _react2['default'].PropTypes.string,\n    // HTML ID(s) of element(s) that should be used to describe this input (for assistive tech)\n    'aria-label': _react2['default'].PropTypes.string,\n    // Aria label (for assistive tech)\n    'aria-labelledby': _react2['default'].PropTypes.string,\n    // HTML ID of an element that should be used as the label (for assistive tech)\n    arrowRenderer: _react2['default'].PropTypes.func,\n    // Create drop-down caret element\n    autoBlur: _react2['default'].PropTypes.bool,\n    // automatically blur the component when an option is selected\n    autofocus: _react2['default'].PropTypes.bool,\n    // autofocus the component on mount\n    autosize: _react2['default'].PropTypes.bool,\n    // whether to enable autosizing or not\n    backspaceRemoves: _react2['default'].PropTypes.bool,\n    // whether backspace removes an item if there is no text input\n    backspaceToRemoveMessage: _react2['default'].PropTypes.string,\n    // Message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label\n    className: _react2['default'].PropTypes.string,\n    // className for the outer element\n    clearAllText: stringOrNode,\n    // title for the \"clear\" control when multi: true\n    clearRenderer: _react2['default'].PropTypes.func,\n    // create clearable x element\n    clearValueText: stringOrNode,\n    // title for the \"clear\" control\n    clearable: _react2['default'].PropTypes.bool,\n    // should it be possible to reset value\n    deleteRemoves: _react2['default'].PropTypes.bool,\n    // whether backspace removes an item if there is no text input\n    delimiter: _react2['default'].PropTypes.string,\n    // delimiter to use to join multiple values for the hidden field value\n    disabled: _react2['default'].PropTypes.bool,\n    // whether the Select is disabled or not\n    dropdownComponent: _react2['default'].PropTypes.func,\n    // dropdown component to render the menu in\n    escapeClearsValue: _react2['default'].PropTypes.bool,\n    // whether escape clears the value when the menu is closed\n    filterOption: _react2['default'].PropTypes.func,\n    // method to filter a single option (option, filterString)\n    filterOptions: _react2['default'].PropTypes.any,\n    // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])\n    ignoreAccents: _react2['default'].PropTypes.bool,\n    // whether to strip diacritics when filtering\n    ignoreCase: _react2['default'].PropTypes.bool,\n    // whether to perform case-insensitive filtering\n    inputProps: _react2['default'].PropTypes.object,\n    // custom attributes for the Input\n    inputRenderer: _react2['default'].PropTypes.func,\n    // returns a custom input component\n    instanceId: _react2['default'].PropTypes.string,\n    // set the components instanceId\n    isLoading: _react2['default'].PropTypes.bool,\n    // whether the Select is loading externally or not (such as options being loaded)\n    isOpen: _react2['default'].PropTypes.bool,\n    // whether the Select dropdown menu is open or not\n    joinValues: _react2['default'].PropTypes.bool,\n    // joins multiple values into a single form field with the delimiter (legacy mode)\n    labelKey: _react2['default'].PropTypes.string,\n    // path of the label value in option objects\n    matchPos: _react2['default'].PropTypes.string,\n    // (any|start) match the start or entire string when filtering\n    matchProp: _react2['default'].PropTypes.string,\n    // (any|label|value) which option property to filter on\n    menuBuffer: _react2['default'].PropTypes.number,\n    // optional buffer (in px) between the bottom of the viewport and the bottom of the menu\n    menuContainerStyle: _react2['default'].PropTypes.object,\n    // optional style to apply to the menu container\n    menuRenderer: _react2['default'].PropTypes.func,\n    // renders a custom menu with options\n    menuStyle: _react2['default'].PropTypes.object,\n    // optional style to apply to the menu\n    multi: _react2['default'].PropTypes.bool,\n    // multi-value input\n    name: _react2['default'].PropTypes.string,\n    // generates a hidden <input /> tag with this field name for html forms\n    noResultsText: stringOrNode,\n    // placeholder displayed when there are no matching search results\n    onBlur: _react2['default'].PropTypes.func,\n    // onBlur handler: function (event) {}\n    onBlurResetsInput: _react2['default'].PropTypes.bool,\n    // whether input is cleared on blur\n    onChange: _react2['default'].PropTypes.func,\n    // onChange handler: function (newValue) {}\n    onClose: _react2['default'].PropTypes.func,\n    // fires when the menu is closed\n    onCloseResetsInput: _react2['default'].PropTypes.bool,\n    // whether input is cleared when menu is closed through the arrow\n    onFocus: _react2['default'].PropTypes.func,\n    // onFocus handler: function (event) {}\n    onInputChange: _react2['default'].PropTypes.func,\n    // onInputChange handler: function (inputValue) {}\n    onInputKeyDown: _react2['default'].PropTypes.func,\n    // input keyDown handler: function (event) {}\n    onMenuScrollToBottom: _react2['default'].PropTypes.func,\n    // fires when the menu is scrolled to the bottom; can be used to paginate options\n    onOpen: _react2['default'].PropTypes.func,\n    // fires when the menu is opened\n    onValueClick: _react2['default'].PropTypes.func,\n    // onClick handler for value labels: function (value, event) {}\n    openAfterFocus: _react2['default'].PropTypes.bool,\n    // boolean to enable opening dropdown when focused\n    openOnFocus: _react2['default'].PropTypes.bool,\n    // always open options menu on focus\n    optionClassName: _react2['default'].PropTypes.string,\n    // additional class(es) to apply to the <Option /> elements\n    optionComponent: _react2['default'].PropTypes.func,\n    // option component to render in dropdown\n    optionGroupComponent: _react2['default'].PropTypes.func,\n    // option group component to render in dropdown\n    optionRenderer: _react2['default'].PropTypes.func,\n    // optionRenderer: function (option) {}\n    options: _react2['default'].PropTypes.array,\n    // array of options\n    pageSize: _react2['default'].PropTypes.number,\n    // number of entries to page when using page up/down keys\n    placeholder: stringOrNode,\n    // field placeholder, displayed when there's no value\n    renderInvalidValues: _react2['default'].PropTypes.bool,\n    // boolean to enable rendering values that do not match any options\n    required: _react2['default'].PropTypes.bool,\n    // applies HTML5 required attribute when needed\n    resetValue: _react2['default'].PropTypes.any,\n    // value to use when you clear the control\n    scrollMenuIntoView: _react2['default'].PropTypes.bool,\n    // boolean to enable the viewport to shift so that the full menu fully visible when engaged\n    searchable: _react2['default'].PropTypes.bool,\n    // whether to enable searching feature or not\n    simpleValue: _react2['default'].PropTypes.bool,\n    // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false\n    style: _react2['default'].PropTypes.object,\n    // optional style to apply to the control\n    tabIndex: _react2['default'].PropTypes.string,\n    // optional tab index of the control\n    tabSelectsValue: _react2['default'].PropTypes.bool,\n    // whether to treat tabbing out while focused to be value selection\n    value: _react2['default'].PropTypes.any,\n    // initial field value\n    valueComponent: _react2['default'].PropTypes.func,\n    // value component to render\n    valueKey: _react2['default'].PropTypes.string,\n    // path of the label value in option objects\n    valueRenderer: _react2['default'].PropTypes.func,\n    // valueRenderer: function (option) {}\n    wrapperStyle: _react2['default'].PropTypes.object\n  },\n  // optional style to apply to the component wrapper\n  statics: {\n    Async: _Async2['default'],\n    AsyncCreatable: _AsyncCreatable2['default'],\n    Creatable: _Creatable2['default']\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      addLabelText: 'Add \"{label}\"?',\n      arrowRenderer: _utilsDefaultArrowRenderer2['default'],\n      autosize: true,\n      backspaceRemoves: true,\n      backspaceToRemoveMessage: 'Press backspace to remove {label}',\n      clearable: true,\n      clearAllText: 'Clear all',\n      clearRenderer: _utilsDefaultClearRenderer2['default'],\n      clearValueText: 'Clear value',\n      deleteRemoves: true,\n      delimiter: ',',\n      disabled: false,\n      dropdownComponent: _Dropdown2['default'],\n      escapeClearsValue: true,\n      filterOptions: _utilsDefaultFilterOptions2['default'],\n      ignoreAccents: true,\n      ignoreCase: true,\n      inputProps: {},\n      isLoading: false,\n      joinValues: false,\n      labelKey: 'label',\n      matchPos: 'any',\n      matchProp: 'any',\n      menuBuffer: 0,\n      menuRenderer: _utilsDefaultMenuRenderer2['default'],\n      multi: false,\n      noResultsText: 'No results found',\n      onBlurResetsInput: true,\n      onCloseResetsInput: true,\n      openAfterFocus: false,\n      optionComponent: _Option2['default'],\n      optionGroupComponent: _OptionGroup2['default'],\n      pageSize: 5,\n      placeholder: 'Select...',\n      renderInvalidValues: false,\n      required: false,\n      scrollMenuIntoView: true,\n      searchable: true,\n      simpleValue: false,\n      tabSelectsValue: true,\n      valueComponent: _Value2['default'],\n      valueKey: 'value'\n    };\n  },\n  getInitialState: function getInitialState() {\n    return {\n      inputValue: '',\n      isFocused: false,\n      isOpen: this.props.isOpen != null ? this.props.isOpen : false,\n      isPseudoFocused: false,\n      required: false\n    };\n  },\n  componentWillMount: function componentWillMount() {\n    this._flatOptions = this.flattenOptions(this.props.options);\n    this._instancePrefix = 'react-select-' + (this.props.instanceId || ++instanceId) + '-';\n    var valueArray = this.getValueArray(this.props.value);\n\n    if (this.props.required) {\n      this.setState({\n        required: this.handleRequired(valueArray[0], this.props.multi)\n      });\n    }\n  },\n  componentDidMount: function componentDidMount() {\n    if (this.props.autofocus) {\n      this.focus();\n    }\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    if (nextProps.options !== this.props.options) {\n      this._flatOptions = this.flattenOptions(nextProps.options);\n    }\n\n    var valueArray = this.getValueArray(nextProps.value, nextProps);\n\n    if (!nextProps.isOpen && this.props.isOpen) {\n      this.closeMenu();\n    }\n\n    if (nextProps.required) {\n      this.setState({\n        required: this.handleRequired(valueArray[0], nextProps.multi)\n      });\n    }\n  },\n  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n    if (nextState.isOpen !== this.state.isOpen) {\n      this.toggleTouchOutsideEvent(nextState.isOpen);\n      var handler = nextState.isOpen ? nextProps.onOpen : nextProps.onClose;\n      handler && handler();\n    }\n  },\n  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n    // focus to the selected option\n    if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {\n      var focusedOptionNode = _reactDom2['default'].findDOMNode(this.focused);\n\n      var focusedOptionPreviousSibling = focusedOptionNode.previousSibling;\n      var focusedOptionParent = focusedOptionNode.parentElement;\n\n      var menuNode = _reactDom2['default'].findDOMNode(this.menu);\n\n      if (focusedOptionPreviousSibling) {\n        menuNode.scrollTop = focusedOptionPreviousSibling.offsetTop;\n      } else if (focusedOptionParent && focusedOptionParent === 'Select-menu') {\n        menuNode.scrollTop = focusedOptionParent.offsetTop;\n      } else {\n        menuNode.scrollTop = focusedOptionNode.offsetTop;\n      }\n\n      var paddingTop = parseInt(window.getComputedStyle(menuNode, null).paddingTop, 10);\n      if (menuNode.scrollTop <= paddingTop) menuNode.scrollTop = 0;\n      this.hasScrolledToOption = true;\n    } else if (!this.state.isOpen) {\n      this.hasScrolledToOption = false;\n    }\n\n    if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {\n      this._scrollToFocusedOptionOnUpdate = false;\n\n      var focusedDOM = _reactDom2['default'].findDOMNode(this.focused);\n\n      var menuDOM = _reactDom2['default'].findDOMNode(this.menu);\n\n      var focusedRect = focusedDOM.getBoundingClientRect();\n      var menuRect = menuDOM.getBoundingClientRect();\n\n      if (focusedRect.bottom > menuRect.bottom || focusedRect.top < menuRect.top) {\n        menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;\n      }\n    }\n\n    if (this.props.scrollMenuIntoView && this.menuContainer) {\n      var menuContainerRect = this.menuContainer.getBoundingClientRect();\n\n      if (window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer) {\n        window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);\n      }\n    }\n\n    if (prevProps.disabled !== this.props.disabled) {\n      this.setState({\n        isFocused: false\n      }); // eslint-disable-line react/no-did-update-set-state\n\n      this.closeMenu();\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (!document.removeEventListener && document.detachEvent) {\n      document.detachEvent('ontouchstart', this.handleTouchOutside);\n    } else {\n      document.removeEventListener('touchstart', this.handleTouchOutside);\n    }\n  },\n  toggleTouchOutsideEvent: function toggleTouchOutsideEvent(enabled) {\n    if (enabled) {\n      if (!document.addEventListener && document.attachEvent) {\n        document.attachEvent('ontouchstart', this.handleTouchOutside);\n      } else {\n        document.addEventListener('touchstart', this.handleTouchOutside);\n      }\n    } else {\n      if (!document.removeEventListener && document.detachEvent) {\n        document.detachEvent('ontouchstart', this.handleTouchOutside);\n      } else {\n        document.removeEventListener('touchstart', this.handleTouchOutside);\n      }\n    }\n  },\n  handleTouchOutside: function handleTouchOutside(event) {\n    // handle touch outside on ios to dismiss menu\n    if (this.wrapper && !this.wrapper.contains(event.target) && this.menuContainer && !this.menuContainer.contains(event.target)) {\n      this.closeMenu();\n    }\n  },\n  focus: function focus() {\n    if (!this.input) return;\n    this.input.focus();\n\n    if (this.props.openAfterFocus) {\n      this.setState({\n        isOpen: true\n      });\n    }\n  },\n  blurInput: function blurInput() {\n    if (!this.input) return;\n    this.input.blur();\n  },\n  handleTouchMove: function handleTouchMove(event) {\n    // Set a flag that the view is being dragged\n    this.dragging = true;\n  },\n  handleTouchStart: function handleTouchStart(event) {\n    // Set a flag that the view is not being dragged\n    this.dragging = false;\n  },\n  handleTouchEnd: function handleTouchEnd(event) {\n    // Check if the view is being dragged, In this case\n    // we don't want to fire the click event (because the user only wants to scroll)\n    if (this.dragging) return; // Fire the mouse events\n\n    this.handleMouseDown(event);\n  },\n  handleTouchEndClearValue: function handleTouchEndClearValue(event) {\n    // Check if the view is being dragged, In this case\n    // we don't want to fire the click event (because the user only wants to scroll)\n    if (this.dragging) return; // Clear the value\n\n    this.clearValue(event);\n  },\n  handleMouseDown: function handleMouseDown(event) {\n    // if the event was triggered by a mousedown and not the primary\n    // button, or if the component is disabled, ignore it.\n    if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {\n      return;\n    }\n\n    if (event.target.tagName === 'INPUT') {\n      return;\n    } // prevent default event handlers\n\n\n    event.stopPropagation();\n    event.preventDefault(); // for the non-searchable select, toggle the menu\n\n    if (!this.props.searchable) {\n      this.focus();\n      return this.setState({\n        isOpen: !this.state.isOpen\n      });\n    }\n\n    if (this.state.isFocused) {\n      // On iOS, we can get into a state where we think the input is focused but it isn't really,\n      // since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.\n      // Call focus() again here to be safe.\n      this.focus();\n      var input = this.input;\n\n      if (typeof input.getInput === 'function') {\n        // Get the actual DOM input if the ref is an <AutosizeInput /> component\n        input = input.getInput();\n      } // clears the value so that the cursor will be at the end of input when the component re-renders\n\n\n      input.value = ''; // if the input is focused, ensure the menu is open\n\n      this.setState({\n        isOpen: true,\n        isPseudoFocused: false\n      });\n    } else {\n      // otherwise, focus the input and open the menu\n      this._openAfterFocus = this.props.openOnFocus;\n      this.focus();\n    }\n  },\n  handleMouseDownOnArrow: function handleMouseDownOnArrow(event) {\n    // if the event was triggered by a mousedown and not the primary\n    // button, or if the component is disabled, ignore it.\n    if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {\n      return;\n    } // If the menu isn't open, let the event bubble to the main handleMouseDown\n\n\n    if (!this.state.isOpen) {\n      return;\n    } // prevent default event handlers\n\n\n    event.stopPropagation();\n    event.preventDefault(); // close the menu\n\n    this.closeMenu();\n  },\n  handleMouseDownOnMenu: function handleMouseDownOnMenu(event) {\n    // if the event was triggered by a mousedown and not the primary\n    // button, or if the component is disabled, ignore it.\n    if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {\n      return;\n    }\n\n    event.stopPropagation();\n    event.preventDefault();\n    this._openAfterFocus = true;\n    this.focus();\n  },\n  closeMenu: function closeMenu() {\n    var _this = this;\n\n    if (this.props.onCloseResetsInput) {\n      this.setState({\n        isOpen: false,\n        isPseudoFocused: this.state.isFocused && !this.props.multi,\n        inputValue: ''\n      }, function () {\n        if (_this.props.onInputChange) _this.props.onInputChange('');\n      });\n    } else {\n      this.setState({\n        isOpen: false,\n        isPseudoFocused: this.state.isFocused && !this.props.multi,\n        inputValue: this.state.inputValue\n      });\n    }\n\n    this.hasScrolledToOption = false;\n  },\n  handleInputFocus: function handleInputFocus(event) {\n    if (this.props.disabled) return;\n    var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;\n\n    if (this.props.onFocus) {\n      this.props.onFocus(event);\n    }\n\n    this.setState({\n      isFocused: true,\n      isOpen: isOpen\n    });\n    this._openAfterFocus = false;\n  },\n  handleInputBlur: function handleInputBlur(event) {\n    // The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.\n    if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) {\n      this.focus();\n      return;\n    }\n\n    if (this.props.onBlur) {\n      this.props.onBlur(event);\n    }\n\n    var onBlurredState = {\n      isFocused: false,\n      isOpen: false,\n      isPseudoFocused: false\n    };\n\n    if (this.props.onBlurResetsInput) {\n      onBlurredState.inputValue = '';\n    }\n\n    this.setState(onBlurredState);\n  },\n  handleInputChange: function handleInputChange(event) {\n    var newInputValue = event.target.value;\n\n    if (this.state.inputValue !== event.target.value && this.props.onInputChange) {\n      var nextState = this.props.onInputChange(newInputValue); // Note: != used deliberately here to catch undefined and null\n\n      if (nextState != null && typeof nextState !== 'object') {\n        newInputValue = '' + nextState;\n      }\n    }\n\n    this.setState({\n      isOpen: true,\n      isPseudoFocused: false,\n      inputValue: newInputValue\n    });\n  },\n  handleKeyDown: function handleKeyDown(event) {\n    if (this.props.disabled) return;\n\n    if (typeof this.props.onInputKeyDown === 'function') {\n      this.props.onInputKeyDown(event);\n\n      if (event.defaultPrevented) {\n        return;\n      }\n    }\n\n    switch (event.keyCode) {\n      case 8:\n        // backspace\n        if (!this.state.inputValue && this.props.backspaceRemoves) {\n          event.preventDefault();\n          this.popValue();\n        }\n\n        return;\n\n      case 9:\n        // tab\n        if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) {\n          return;\n        }\n\n        this.selectFocusedOption();\n        return;\n\n      case 13:\n        // enter\n        if (!this.state.isOpen) {\n          this.setState({\n            isOpen: true\n          });\n          return;\n        }\n\n        ;\n        event.stopPropagation();\n        this.selectFocusedOption();\n        break;\n\n      case 27:\n        // escape\n        if (this.state.isOpen) {\n          this.closeMenu();\n          event.stopPropagation();\n        } else if (this.props.clearable && this.props.escapeClearsValue) {\n          this.clearValue(event);\n          event.stopPropagation();\n        }\n\n        break;\n\n      case 38:\n        // up\n        this.focusPreviousOption();\n        break;\n\n      case 40:\n        // down\n        this.focusNextOption();\n        break;\n\n      case 33:\n        // page up\n        this.focusPageUpOption();\n        break;\n\n      case 34:\n        // page down\n        this.focusPageDownOption();\n        break;\n\n      case 35:\n        // end key\n        if (event.shiftKey) {\n          return;\n        }\n\n        this.focusEndOption();\n        break;\n\n      case 36:\n        // home key\n        if (event.shiftKey) {\n          return;\n        }\n\n        this.focusStartOption();\n        break;\n\n      case 46:\n        // backspace\n        if (!this.state.inputValue && this.props.deleteRemoves) {\n          event.preventDefault();\n          this.popValue();\n        }\n\n        return;\n\n      default:\n        return;\n    }\n\n    event.preventDefault();\n  },\n  handleValueClick: function handleValueClick(option, event) {\n    if (!this.props.onValueClick) return;\n    this.props.onValueClick(option, event);\n  },\n  handleMenuScroll: function handleMenuScroll(event) {\n    if (!this.props.onMenuScrollToBottom) return;\n    var target = event.target;\n\n    if (target.scrollHeight > target.offsetHeight && !(target.scrollHeight - target.offsetHeight - target.scrollTop)) {\n      this.props.onMenuScrollToBottom();\n    }\n  },\n  handleRequired: function handleRequired(value, multi) {\n    if (!value) return true;\n    return multi ? value.length === 0 : Object.keys(value).length === 0;\n  },\n  getOptionLabel: function getOptionLabel(op) {\n    return op[this.props.labelKey];\n  },\n\n  /**\n   * Turns a value into an array from the given options\n   * @param\t{String|Number|Array}\tvalue\t\t- the value of the select input\n   * @param\t{Object}\t\tnextProps\t- optionally specify the nextProps so the returned array uses the latest configuration\n   * @returns\t{Array}\tthe value of the select represented in an array\n   */\n  getValueArray: function getValueArray(value, nextProps) {\n    var _this2 = this;\n    /** support optionally passing in the `nextProps` so `componentWillReceiveProps` updates will function as expected */\n\n\n    var props = typeof nextProps === 'object' ? nextProps : this.props;\n\n    if (props.multi) {\n      if (typeof value === 'string') value = value.split(props.delimiter);\n\n      if (!Array.isArray(value)) {\n        if (value === null || value === undefined) return [];\n        value = [value];\n      }\n\n      return value.map(function (value) {\n        return _this2.expandValue(value, props);\n      }).filter(function (i) {\n        return i;\n      });\n    }\n\n    var expandedValue = this.expandValue(value, props);\n    return expandedValue ? [expandedValue] : [];\n  },\n\n  /**\n   * Retrieve a value from the given options and valueKey\n   * @param\t{String|Number|Array}\tvalue\t- the selected value(s)\n   * @param\t{Object}\t\tprops\t- the Select component's props (or nextProps)\n   */\n  expandValue: function expandValue(value, props) {\n    var valueType = typeof value;\n    if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') return value;\n    var _props = this.props;\n    var labelKey = _props.labelKey;\n    var valueKey = _props.valueKey;\n    var renderInvalidValues = _props.renderInvalidValues;\n    var options = this._flatOptions;\n    if (!options || value === '') return;\n\n    for (var i = 0; i < options.length; i++) {\n      if (options[i][valueKey] === value) return options[i];\n    } // no matching option, return an invalid option if renderInvalidValues is enabled\n\n\n    if (renderInvalidValues) {\n      var _ref;\n\n      invalidOptions[value] = invalidOptions[value] || (_ref = {\n        invalid: true\n      }, _defineProperty(_ref, labelKey, value), _defineProperty(_ref, valueKey, value), _ref);\n      return invalidOptions[value];\n    }\n  },\n  setValue: function setValue(value) {\n    var _this3 = this;\n\n    if (this.props.autoBlur) {\n      this.blurInput();\n    }\n\n    if (!this.props.onChange) return;\n\n    if (this.props.required) {\n      var required = this.handleRequired(value, this.props.multi);\n      this.setState({\n        required: required\n      });\n    }\n\n    if (this.props.simpleValue && value) {\n      value = this.props.multi ? value.map(function (i) {\n        return i[_this3.props.valueKey];\n      }).join(this.props.delimiter) : value[this.props.valueKey];\n    }\n\n    this.props.onChange(value);\n  },\n  selectValue: function selectValue(value) {\n    var _this4 = this; //NOTE: update value in the callback to make sure the input value is empty so that there are no styling issues (Chrome had issue otherwise)\n\n\n    this.hasScrolledToOption = false;\n\n    if (this.props.multi) {\n      this.setState({\n        inputValue: '',\n        focusedIndex: null\n      }, function () {\n        _this4.addValue(value);\n\n        if (_this4.props.onInputChange) _this4.props.onInputChange('');\n      });\n    } else {\n      this.setState({\n        isOpen: false,\n        inputValue: '',\n        isPseudoFocused: this.state.isFocused\n      }, function () {\n        _this4.setValue(value);\n\n        if (_this4.props.onInputChange) _this4.props.onInputChange('');\n      });\n    }\n  },\n  addValue: function addValue(value) {\n    var valueArray = this.getValueArray(this.props.value);\n\n    var visibleOptions = this._visibleOptions.filter(function (val) {\n      return !val.disabled;\n    });\n\n    var lastValueIndex = visibleOptions.indexOf(value);\n    this.setValue(valueArray.concat(value));\n\n    if (visibleOptions.length - 1 === lastValueIndex) {\n      // the last option was selected; focus the second-last one\n      this.focusOption(visibleOptions[lastValueIndex - 1]);\n    } else if (visibleOptions.length > lastValueIndex) {\n      // focus the option below the selected one\n      this.focusOption(visibleOptions[lastValueIndex + 1]);\n    }\n  },\n  popValue: function popValue() {\n    var valueArray = this.getValueArray(this.props.value);\n    if (!valueArray.length) return;\n    if (valueArray[valueArray.length - 1].clearableValue === false) return;\n    this.setValue(valueArray.slice(0, valueArray.length - 1));\n  },\n  removeValue: function removeValue(value) {\n    var valueArray = this.getValueArray(this.props.value);\n    this.setValue(valueArray.filter(function (i) {\n      return i !== value;\n    }));\n  },\n  clearValue: function clearValue(event) {\n    var _this5 = this; // if the event was triggered by a mousedown and not the primary\n    // button, ignore it.\n\n\n    if (event && event.type === 'mousedown' && event.button !== 0) {\n      return;\n    }\n\n    event.stopPropagation();\n    event.preventDefault();\n    this.setValue(this.getResetValue());\n    this.setState({\n      isOpen: false,\n      inputValue: ''\n    }, function () {\n      _this5.focus();\n\n      if (_this5.props.onInputChange) _this5.props.onInputChange('');\n    });\n  },\n  getResetValue: function getResetValue() {\n    if (this.props.resetValue !== undefined) {\n      return this.props.resetValue;\n    } else if (this.props.multi) {\n      return [];\n    } else {\n      return null;\n    }\n  },\n  focusOption: function focusOption(option) {\n    this.setState({\n      focusedOption: option\n    });\n  },\n  focusNextOption: function focusNextOption() {\n    this.focusAdjacentOption('next');\n  },\n  focusPreviousOption: function focusPreviousOption() {\n    this.focusAdjacentOption('previous');\n  },\n  focusPageUpOption: function focusPageUpOption() {\n    this.focusAdjacentOption('page_up');\n  },\n  focusPageDownOption: function focusPageDownOption() {\n    this.focusAdjacentOption('page_down');\n  },\n  focusStartOption: function focusStartOption() {\n    this.focusAdjacentOption('start');\n  },\n  focusEndOption: function focusEndOption() {\n    this.focusAdjacentOption('end');\n  },\n  focusAdjacentOption: function focusAdjacentOption(dir) {\n    var _this6 = this;\n\n    var options = this._visibleOptions.map(function (option, index) {\n      return {\n        option: option,\n        index: index\n      };\n    }).filter(function (option) {\n      return !option.option.disabled;\n    });\n\n    this._scrollToFocusedOptionOnUpdate = true;\n\n    if (!this.state.isOpen) {\n      this.setState({\n        isOpen: true,\n        inputValue: '',\n        focusedOption: this._focusedOption || (options.length ? options[dir === 'next' ? 0 : options.length - 1].option : null)\n      }, function () {\n        if (_this6.props.onInputChange) _this6.props.onInputChange('');\n      });\n      return;\n    }\n\n    if (!options.length) return;\n    var focusedIndex = -1;\n\n    for (var i = 0; i < options.length; i++) {\n      if (this._focusedOption === options[i].option) {\n        focusedIndex = i;\n        break;\n      }\n    }\n\n    if (dir === 'next' && focusedIndex !== -1) {\n      focusedIndex = (focusedIndex + 1) % options.length;\n    } else if (dir === 'previous') {\n      if (focusedIndex > 0) {\n        focusedIndex = focusedIndex - 1;\n      } else {\n        focusedIndex = options.length - 1;\n      }\n    } else if (dir === 'start') {\n      focusedIndex = 0;\n    } else if (dir === 'end') {\n      focusedIndex = options.length - 1;\n    } else if (dir === 'page_up') {\n      var potentialIndex = focusedIndex - this.props.pageSize;\n\n      if (potentialIndex < 0) {\n        focusedIndex = 0;\n      } else {\n        focusedIndex = potentialIndex;\n      }\n    } else if (dir === 'page_down') {\n      var potentialIndex = focusedIndex + this.props.pageSize;\n\n      if (potentialIndex > options.length - 1) {\n        focusedIndex = options.length - 1;\n      } else {\n        focusedIndex = potentialIndex;\n      }\n    }\n\n    if (focusedIndex === -1) {\n      focusedIndex = 0;\n    }\n\n    this.setState({\n      focusedIndex: options[focusedIndex].index,\n      focusedOption: options[focusedIndex].option\n    });\n  },\n  getFocusedOption: function getFocusedOption() {\n    return this._focusedOption;\n  },\n  getInputValue: function getInputValue() {\n    return this.state.inputValue;\n  },\n  selectFocusedOption: function selectFocusedOption() {\n    if (this._focusedOption) {\n      return this.selectValue(this._focusedOption);\n    }\n  },\n  renderLoading: function renderLoading() {\n    if (!this.props.isLoading) return;\n    return _react2['default'].createElement('span', {\n      className: 'Select-loading-zone',\n      'aria-hidden': 'true'\n    }, _react2['default'].createElement('span', {\n      className: 'Select-loading'\n    }));\n  },\n  renderValue: function renderValue(valueArray, isOpen) {\n    var _this7 = this;\n\n    var renderLabel = this.props.valueRenderer || this.getOptionLabel;\n    var ValueComponent = this.props.valueComponent;\n\n    if (!valueArray.length) {\n      return !this.state.inputValue ? _react2['default'].createElement('div', {\n        className: 'Select-placeholder'\n      }, this.props.placeholder) : null;\n    }\n\n    var onClick = this.props.onValueClick ? this.handleValueClick : null;\n\n    if (this.props.multi) {\n      return valueArray.map(function (value, i) {\n        return _react2['default'].createElement(ValueComponent, {\n          id: _this7._instancePrefix + '-value-' + i,\n          instancePrefix: _this7._instancePrefix,\n          disabled: _this7.props.disabled || value.clearableValue === false,\n          key: 'value-' + i + '-' + value[_this7.props.valueKey],\n          onClick: onClick,\n          onRemove: _this7.removeValue,\n          value: value\n        }, renderLabel(value, i), _react2['default'].createElement('span', {\n          className: 'Select-aria-only'\n        }, 'Â '));\n      });\n    } else if (!this.state.inputValue) {\n      if (isOpen) onClick = null;\n      return _react2['default'].createElement(ValueComponent, {\n        id: this._instancePrefix + '-value-item',\n        disabled: this.props.disabled,\n        instancePrefix: this._instancePrefix,\n        onClick: onClick,\n        value: valueArray[0]\n      }, renderLabel(valueArray[0]));\n    }\n  },\n  renderInput: function renderInput(valueArray, focusedOptionIndex) {\n    var _classNames,\n        _this8 = this;\n\n    var className = (0, _classnames2['default'])('Select-input', this.props.inputProps.className);\n    var isOpen = !!this.state.isOpen;\n    var ariaOwns = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, this._instancePrefix + '-list', isOpen), _defineProperty(_classNames, this._instancePrefix + '-backspace-remove-message', this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), _classNames)); // TODO: Check how this project includes Object.assign()\n\n    var inputProps = _extends({}, this.props.inputProps, {\n      role: 'combobox',\n      'aria-expanded': '' + isOpen,\n      'aria-owns': ariaOwns,\n      'aria-haspopup': '' + isOpen,\n      'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',\n      'aria-describedby': this.props['aria-describedby'],\n      'aria-labelledby': this.props['aria-labelledby'],\n      'aria-label': this.props['aria-label'],\n      className: className,\n      tabIndex: this.props.tabIndex,\n      onBlur: this.handleInputBlur,\n      onChange: this.handleInputChange,\n      onFocus: this.handleInputFocus,\n      ref: function ref(_ref2) {\n        return _this8.input = _ref2;\n      },\n      required: this.state.required,\n      value: this.state.inputValue\n    });\n\n    if (this.props.inputRenderer) {\n      return this.props.inputRenderer(inputProps);\n    }\n\n    if (this.props.disabled || !this.props.searchable) {\n      var _props$inputProps = this.props.inputProps;\n      var inputClassName = _props$inputProps.inputClassName;\n\n      var divProps = _objectWithoutProperties(_props$inputProps, ['inputClassName']);\n\n      return _react2['default'].createElement('div', _extends({}, divProps, {\n        role: 'combobox',\n        'aria-expanded': isOpen,\n        'aria-owns': isOpen ? this._instancePrefix + '-list' : this._instancePrefix + '-value',\n        'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',\n        className: className,\n        tabIndex: this.props.tabIndex || 0,\n        onBlur: this.handleInputBlur,\n        onFocus: this.handleInputFocus,\n        ref: function ref(_ref3) {\n          return _this8.input = _ref3;\n        },\n        'aria-readonly': '' + !!this.props.disabled,\n        style: {\n          border: 0,\n          width: 1,\n          display: 'inline-block'\n        }\n      }));\n    }\n\n    if (this.props.autosize) {\n      return _react2['default'].createElement(_reactInputAutosize2['default'], _extends({}, inputProps, {\n        minWidth: '5'\n      }));\n    }\n\n    return _react2['default'].createElement('div', {\n      className: className\n    }, _react2['default'].createElement('input', inputProps));\n  },\n  renderClear: function renderClear() {\n    if (!this.props.clearable || !this.props.value || this.props.value === 0 || this.props.multi && !this.props.value.length || this.props.disabled || this.props.isLoading) return;\n    var clear = this.props.clearRenderer();\n    return _react2['default'].createElement('span', {\n      className: 'Select-clear-zone',\n      title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,\n      'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText,\n      onMouseDown: this.clearValue,\n      onTouchStart: this.handleTouchStart,\n      onTouchMove: this.handleTouchMove,\n      onTouchEnd: this.handleTouchEndClearValue\n    }, clear);\n  },\n  renderArrow: function renderArrow() {\n    var onMouseDown = this.handleMouseDownOnArrow;\n    var isOpen = this.state.isOpen;\n    var arrow = this.props.arrowRenderer({\n      onMouseDown: onMouseDown,\n      isOpen: isOpen\n    });\n    return _react2['default'].createElement('span', {\n      className: 'Select-arrow-zone',\n      onMouseDown: onMouseDown\n    }, arrow);\n  },\n  filterFlatOptions: function filterFlatOptions(excludeOptions) {\n    var filterValue = this.state.inputValue;\n    var flatOptions = this._flatOptions;\n\n    if (this.props.filterOptions) {\n      // Maintain backwards compatibility with boolean attribute\n      var filterOptions = typeof this.props.filterOptions === 'function' ? this.props.filterOptions : _utilsDefaultFilterOptions2['default'];\n      return filterOptions(flatOptions, filterValue, excludeOptions, {\n        filterOption: this.props.filterOption,\n        ignoreAccents: this.props.ignoreAccents,\n        ignoreCase: this.props.ignoreCase,\n        labelKey: this.props.labelKey,\n        matchPos: this.props.matchPos,\n        matchProp: this.props.matchProp,\n        valueKey: this.props.valueKey\n      });\n    } else {\n      return flatOptions;\n    }\n  },\n  flattenOptions: function flattenOptions(options, group) {\n    if (!options) return [];\n    var flatOptions = [];\n\n    for (var i = 0; i < options.length; i++) {\n      // We clone each option with a pointer to its parent group for efficient unflattening\n      var optionCopy = clone(options[i]);\n      optionCopy.isInTree = false;\n\n      if (group) {\n        optionCopy.group = group;\n      }\n\n      if (isGroup(optionCopy)) {\n        flatOptions = flatOptions.concat(this.flattenOptions(optionCopy.options, optionCopy));\n        optionCopy.options = [];\n      } else {\n        flatOptions.push(optionCopy);\n      }\n    }\n\n    return flatOptions;\n  },\n  unflattenOptions: function unflattenOptions(flatOptions) {\n    var groupedOptions = [];\n    var parent = undefined,\n        child = undefined; // Remove all ancestor groups from the tree\n\n    flatOptions.forEach(function (option) {\n      option.isInTree = false;\n      parent = option.group;\n\n      while (parent) {\n        if (parent.isInTree) {\n          parent.options = [];\n          parent.isInTree = false;\n        }\n\n        parent = parent.group;\n      }\n    }); // Now reconstruct the options tree\n\n    flatOptions.forEach(function (option) {\n      child = option;\n      parent = child.group;\n\n      while (parent) {\n        if (!child.isInTree) {\n          parent.options.push(child);\n          child.isInTree = true;\n        }\n\n        child = parent;\n        parent = child.group;\n      }\n\n      if (!child.isInTree) {\n        groupedOptions.push(child);\n        child.isInTree = true;\n      }\n    });\n    return groupedOptions;\n  },\n  onOptionRef: function onOptionRef(ref, isFocused) {\n    if (isFocused) {\n      this.focused = ref;\n    }\n  },\n  renderMenu: function renderMenu(options, valueArray, focusedOption) {\n    if (options && options.length) {\n      return this.props.menuRenderer({\n        focusedOption: focusedOption,\n        focusOption: this.focusOption,\n        instancePrefix: this._instancePrefix,\n        labelKey: this.props.labelKey,\n        onFocus: this.focusOption,\n        onOptionRef: this.onOptionRef,\n        onSelect: this.selectValue,\n        optionClassName: this.props.optionClassName,\n        optionComponent: this.props.optionComponent,\n        optionGroupComponent: this.props.optionGroupComponent,\n        optionRenderer: this.props.optionRenderer || this.getOptionLabel,\n        options: options,\n        selectValue: this.selectValue,\n        valueArray: valueArray,\n        valueKey: this.props.valueKey\n      });\n    } else if (this.props.noResultsText) {\n      return _react2['default'].createElement('div', {\n        className: 'Select-noresults'\n      }, this.props.noResultsText);\n    } else {\n      return null;\n    }\n  },\n  renderHiddenField: function renderHiddenField(valueArray) {\n    var _this9 = this;\n\n    if (!this.props.name) return;\n\n    if (this.props.joinValues) {\n      var value = valueArray.map(function (i) {\n        return stringifyValue(i[_this9.props.valueKey]);\n      }).join(this.props.delimiter);\n      return _react2['default'].createElement('input', {\n        type: 'hidden',\n        ref: function ref(_ref4) {\n          return _this9.value = _ref4;\n        },\n        name: this.props.name,\n        value: value,\n        disabled: this.props.disabled\n      });\n    }\n\n    return valueArray.map(function (item, index) {\n      return _react2['default'].createElement('input', {\n        key: 'hidden.' + index,\n        type: 'hidden',\n        ref: 'value' + index,\n        name: _this9.props.name,\n        value: stringifyValue(item[_this9.props.valueKey]),\n        disabled: _this9.props.disabled\n      });\n    });\n  },\n  getFocusableOptionIndex: function getFocusableOptionIndex(selectedOption) {\n    var options = this._visibleOptions;\n    if (!options.length) return null;\n    var focusedOption = this.state.focusedOption || selectedOption;\n\n    if (focusedOption && !focusedOption.disabled) {\n      var focusedOptionIndex = -1;\n      options.some(function (option, index) {\n        var isOptionEqual = option.value === focusedOption.value;\n\n        if (isOptionEqual) {\n          focusedOptionIndex = index;\n        }\n\n        return isOptionEqual;\n      });\n\n      if (focusedOptionIndex !== -1) {\n        return focusedOptionIndex;\n      }\n    }\n\n    for (var i = 0; i < options.length; i++) {\n      if (!options[i].disabled) return i;\n    }\n\n    return null;\n  },\n  renderOuter: function renderOuter(options, valueArray, focusedOption) {\n    var _this10 = this;\n\n    var Dropdown = this.props.dropdownComponent;\n    var menu = this.renderMenu(options, valueArray, focusedOption);\n\n    if (!menu) {\n      return null;\n    }\n\n    return _react2['default'].createElement(Dropdown, null, _react2['default'].createElement('div', {\n      ref: function ref(_ref5) {\n        return _this10.menuContainer = _ref5;\n      },\n      className: 'Select-menu-outer',\n      style: this.props.menuContainerStyle\n    }, _react2['default'].createElement('div', {\n      ref: function ref(_ref6) {\n        return _this10.menu = _ref6;\n      },\n      role: 'listbox',\n      className: 'Select-menu',\n      id: this._instancePrefix + '-list',\n      style: this.props.menuStyle,\n      onScroll: this.handleMenuScroll,\n      onMouseDown: this.handleMouseDownOnMenu\n    }, menu)));\n  },\n  render: function render() {\n    var _this11 = this;\n\n    var valueArray = this.getValueArray(this.props.value);\n    this._visibleOptions = this.filterFlatOptions(this.props.multi ? valueArray : null);\n    var options = this.unflattenOptions(this._visibleOptions);\n    var isOpen = typeof this.props.isOpen === 'boolean' ? this.props.isOpen : this.state.isOpen;\n    var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]);\n    var focusedOption = null;\n\n    if (focusedOptionIndex !== null) {\n      focusedOption = this._focusedOption = this._visibleOptions[focusedOptionIndex];\n    } else {\n      focusedOption = this._focusedOption = null;\n    }\n\n    var className = (0, _classnames2['default'])('Select', this.props.className, {\n      'Select--multi': this.props.multi,\n      'Select--single': !this.props.multi,\n      'is-disabled': this.props.disabled,\n      'is-focused': this.state.isFocused,\n      'is-loading': this.props.isLoading,\n      'is-open': isOpen,\n      'is-pseudo-focused': this.state.isPseudoFocused,\n      'is-searchable': this.props.searchable,\n      'has-value': valueArray.length\n    });\n    var removeMessage = null;\n\n    if (this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves) {\n      removeMessage = _react2['default'].createElement('span', {\n        id: this._instancePrefix + '-backspace-remove-message',\n        className: 'Select-aria-only',\n        'aria-live': 'assertive'\n      }, this.props.backspaceToRemoveMessage.replace('{label}', valueArray[valueArray.length - 1][this.props.labelKey]));\n    }\n\n    return _react2['default'].createElement('div', {\n      ref: function ref(_ref7) {\n        return _this11.wrapper = _ref7;\n      },\n      className: className,\n      style: this.props.wrapperStyle\n    }, this.renderHiddenField(valueArray), _react2['default'].createElement('div', {\n      ref: function ref(_ref8) {\n        return _this11.control = _ref8;\n      },\n      className: 'Select-control',\n      style: this.props.style,\n      onKeyDown: this.handleKeyDown,\n      onMouseDown: this.handleMouseDown,\n      onTouchEnd: this.handleTouchEnd,\n      onTouchStart: this.handleTouchStart,\n      onTouchMove: this.handleTouchMove\n    }, _react2['default'].createElement('span', {\n      className: 'Select-multi-value-wrapper',\n      id: this._instancePrefix + '-value'\n    }, this.renderValue(valueArray, isOpen), this.renderInput(valueArray, focusedOptionIndex)), removeMessage, this.renderLoading(), this.renderClear(), this.renderArrow()), isOpen ? this.renderOuter(options, !this.props.multi ? valueArray : null, focusedOption) : null);\n  }\n});\n\nSelect.stripDiacritics = _utilsStripDiacritics2['default'];\nexports['default'] = Select;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}