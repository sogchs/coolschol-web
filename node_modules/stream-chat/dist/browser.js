'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _slicedToArray = _interopDefault(require('@babel/runtime/helpers/slicedToArray'));
var _toConsumableArray = _interopDefault(require('@babel/runtime/helpers/toConsumableArray'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/objectWithoutProperties'));
var _objectSpread = _interopDefault(require('@babel/runtime/helpers/objectSpread'));
var _regeneratorRuntime = _interopDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var _classCallCheck = _interopDefault(require('@babel/runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var _typeof = _interopDefault(require('@babel/runtime/helpers/typeof'));
var axios = _interopDefault(require('axios'));
var uuidv4 = _interopDefault(require('uuid/v4'));
var Immutable = _interopDefault(require('seamless-immutable'));
var isoWS = _interopDefault(require('isomorphic-ws'));
var fetch = require('cross-fetch');
var fetch__default = _interopDefault(fetch);
var FormData = _interopDefault(require('form-data'));

/**
 * ChannelState - A container class for the channel state.
 */

function byDate(a, b) {
  return a.created_at - b.created_at;
}

var ChannelState =
/*#__PURE__*/
function () {
  function ChannelState(channel) {
    _classCallCheck(this, ChannelState);

    this._channel = channel;
    this.watcher_count = 0;
    this.typing = Immutable({});
    this.read = Immutable({});
    this.messages = Immutable([]);
    this.threads = Immutable({}); // a list of users to hide messages from

    this.mutedUsers = Immutable([]);
    this.watchers = Immutable({});
    this.members = Immutable({});
  }
  /**
   * addMessageSorted - Add a message to the state
   *
   * @param {object} newMessage A new message
   *
   */


  _createClass(ChannelState, [{
    key: "addMessageSorted",
    value: function addMessageSorted(newMessage) {
      return this.addMessagesSorted([newMessage]);
    }
    /**
     * messageToImmutable - Takes the message object. Parses the dates, sets __html
     * and sets the status to received if missing. Returns an immutable message object
     *
     * @param {object} message an Immutable message object
     *
     */

  }, {
    key: "messageToImmutable",
    value: function messageToImmutable(message) {
      message.__html = message.html; // parse the date..

      message.created_at = new Date(message.created_at);
      message.updated_at = new Date(message.updated_at);

      if (!message.status) {
        message.status = 'received';
      }

      return Immutable(message);
    }
    /**
     * addMessagesSorted - Add the list of messages to state and resorts the messages
     *
     * @param {array} newMessages A list of messages
     *
     */

  }, {
    key: "addMessagesSorted",
    value: function addMessagesSorted(newMessages) {
      // parse all the new message dates and add __html for react
      var parsedMessages = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var message = _step.value;
          parsedMessages.push(this.messageToImmutable(message));
        } // update or append the messages...

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var updatedThreads = [];

      for (var _i = 0; _i < parsedMessages.length; _i++) {
        var _message = parsedMessages[_i];
        var isThreadReply = _message.parent_id && !_message.show_in_channel; // add to the main message list

        if (!isThreadReply) {
          this.messages = this._addToMessageList(this.messages, _message);
        } // add to the thread if applicable..


        var parentID = _message.parent_id;

        if (parentID) {
          var thread = this.threads[parentID] || Immutable([]);

          var threadMessages = this._addToMessageList(thread, _message);

          this.threads = this.threads.set(parentID, threadMessages);
          updatedThreads.push(parentID);
        }
      } // Resort the main messages and the threads that changed...


      var messages = _toConsumableArray(this.messages);

      messages.sort(byDate);
      this.messages = Immutable(messages);

      for (var _i2 = 0; _i2 < updatedThreads.length; _i2++) {
        var _parentID = updatedThreads[_i2];

        var _threadMessages = this.threads[_parentID] ? _toConsumableArray(this.threads[_parentID]) : [];

        _threadMessages.sort(byDate);

        this.threads = this.threads.set(_parentID, _threadMessages);
      }
    }
    /**
     * _addToMessageList - Adds a message to a list of messages, tries to update first, appends if message isnt found
     *
     * @param {array} messages A list of messages
     * @param {object} newMessage The new message
     *
     */

  }, {
    key: "_addToMessageList",
    value: function _addToMessageList(messages, newMessage) {
      var updated = false;

      for (var i = 0; i < messages.length; i++) {
        var message = messages[i];
        var idMatch = message.id && newMessage.id && message.id === newMessage.id;

        if (idMatch) {
          messages = messages.set(i, newMessage);
          updated = true;
        }
      }

      if (!updated) {
        messages = messages.concat([newMessage]);
      }

      return messages;
    }
    /**
     * removeMessage - Description
     *
     * @param {type} messageToRemove Object of the message to remove. Needs to have at id specified.
     *
     * @return {boolean} Returns if the message was removed
     */

  }, {
    key: "removeMessage",
    value: function removeMessage(messageToRemove) {
      var removed = false;
      var messages = this.messages.flatMap(function (message) {
        var idMatch = message.id && messageToRemove.id && message.id === messageToRemove.id;

        if (idMatch) {
          return [];
        } else {
          removed = true;
          return message;
        }
      });
      this.messages = messages;
      return removed;
    }
    /**
     * filterErrorMessages - Removes error messages from the channel state.
     *
     */

  }, {
    key: "filterErrorMessages",
    value: function filterErrorMessages() {
      var filteredMessages = this.messages.flatMap(function (message) {
        if (message.type !== 'error') {
          return message;
        } else {
          return [];
        }
      });
      this.messages = Immutable(filteredMessages);
    }
    /**
     * clean - Remove stale data such as users that stayed in typing state for more than 5 seconds
     */

  }, {
    key: "clean",
    value: function clean() {
      var now = new Date(); // prevent old users from showing up as typing

      var _arr = Object.entries(this.typing);

      for (var _i3 = 0; _i3 < _arr.length; _i3++) {
        var _arr$_i = _slicedToArray(_arr[_i3], 2),
            userID = _arr$_i[0],
            lastEvent = _arr$_i[1];

        var since = now - new Date(lastEvent.received_at);

        if (since > 7000) {
          this.typing = this.typing.without(userID);

          this._channel.client.dispatchEvent({
            type: 'typing.stop',
            user: {
              id: userID
            },
            cid: this._channel.cid
          });
        }
      }
    }
  }]);

  return ChannelState;
}();

var EVENT_MAP = {
  'user.presence.changed': true,
  'user.watching.start': true,
  'user.watching.stop': true,
  'user.updated': true,
  'typing.start': true,
  'typing.stop': true,
  'message.new': true,
  'message.updated': true,
  'message.deleted': true,
  'message.read': true,
  'message.reaction': true,
  'member.added': true,
  'member.updated': true,
  'member.removed': true,
  'channel.updated': true,
  'health.check': true,
  'notification.message_new': true,
  'notification.mark_read': true,
  'notification.invited': true,
  'notification.invite_accepted': true,
  'notification.added_to_channel': true,
  'notification.removed_from_channel': true,
  // local events
  'connection.changed': true,
  'connection.recovered': true
};
function isValidEventType(eventType) {
  if (eventType === 'all') {
    return true;
  }

  return EVENT_MAP[eventType] || false;
}

/**
 * logChatPromiseExecution - utility function for logging the execution of a promise..
 *  use this when you want to run the promise and handle errors by logging a warning
 *
 * @param {type} promise The promise you want to run and log
 * @param {type} name    A descriptive name of what the promise does for log output
 *
 */
function logChatPromiseExecution(promise, name) {
  promise.then(function () {// do nothing...
  }).catch(function (error) {
    console.warn("failed to do ".concat(name, ", ran into error: "), error);
  });
}
var sleep = function sleep(m) {
  return new Promise(function (r) {
    return setTimeout(r, m);
  });
};

/**
 * Channel - The Channel class manages it's own state.
 */

var Channel =
/*#__PURE__*/
function () {
  /**
   * constructor - Create a channel
   *
   * @param {Client} client the chat client
   * @param {string} type  the type of channel
   * @param {string} [id]  the id of the chat
   * @param {type} custom any additional custom params
   *
   * @return {Channel} Returns a new uninitialized channel
   */
  function Channel(client, type, id, data) {
    var _this = this;

    _classCallCheck(this, Channel);

    _defineProperty(this, "create",
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee() {
      var options;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = {
                watch: false,
                state: false,
                presence: false
              };
              _context.next = 3;
              return _this.query(options);

            case 3:
              return _context.abrupt("return", _context.sent);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    })));

    _defineProperty(this, "_channelURL", function () {
      if (!_this.id) {
        throw new Error('channel id is not defined');
      }

      var channelURL = "".concat(_this.client.baseURL, "/channels/").concat(_this.type, "/").concat(_this.id);
      return channelURL;
    });

    var validTypeRe = /^[\w_-]+$/;
    var validIDRe = /^[\w!_-]+$/;

    if (!validTypeRe.test(type)) {
      throw new Error("Invalid chat type ".concat(type, ", letters, numbers and \"_-\" are allowed"));
    }

    if (!validIDRe.test(id)) {
      throw new Error("Invalid chat id ".concat(id, ", letters, numbers and \"!-_\" are allowed"));
    }

    this.client = client;
    this.type = type;
    this.id = id; // used by the frontend, gets updated:

    this.data = data; // this._data is used for the requests...

    this._data = _objectSpread({}, data);
    this.cid = "".concat(type, ":").concat(id);
    this.listeners = {}; // perhaps the state variable should be private

    this.state = new ChannelState(this);
    this.initialized = false;
    this.lastTypingEvent = null;
    this.isTyping = false;
  }
  /**
   * getConfig - Get the configs for this channel type
   *
   * @return {object}
   */


  _createClass(Channel, [{
    key: "getConfig",
    value: function getConfig() {
      return this.client.configs[this.type];
    }
    /**
     * sendMessage - Send a message to this channel
     *
     * @param {object} message The Message object
     *
     * @return {object} The Server Response
     */

  }, {
    key: "sendMessage",
    value: function () {
      var _sendMessage = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(message) {
        var data;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.client.post(this._channelURL() + '/message', {
                  message: message
                });

              case 2:
                data = _context2.sent;
                return _context2.abrupt("return", data);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sendMessage(_x) {
        return _sendMessage.apply(this, arguments);
      }

      return sendMessage;
    }()
  }, {
    key: "sendFile",
    value: function sendFile(uri, name, contentType, user) {
      return this.client.sendFile("".concat(this._channelURL(), "/file"), uri, name, contentType, user);
    }
  }, {
    key: "sendImage",
    value: function sendImage(uri, name, contentType, user) {
      return this.client.sendFile("".concat(this._channelURL(), "/image"), uri, name, contentType, user);
    }
  }, {
    key: "deleteFile",
    value: function deleteFile(url) {
      return this.client.delete("".concat(this._channelURL(), "/file"), {
        url: url
      });
    }
  }, {
    key: "deleteImage",
    value: function deleteImage(url) {
      return this.client.delete("".concat(this._channelURL(), "/image"), {
        url: url
      });
    }
    /**
     * sendEvent - Send an event on this channel
     *
     * @param {object} chatEvent for example {type: 'message.read'}
     *
     * @return {object} The Server Response
     */

  }, {
    key: "sendEvent",
    value: function () {
      var _sendEvent = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3(chatEvent) {
        var data;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._checkInitialized();

                _context3.next = 3;
                return this.client.post(this._channelURL() + '/event', {
                  event: chatEvent
                });

              case 3:
                data = _context3.sent;
                return _context3.abrupt("return", data);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sendEvent(_x2) {
        return _sendEvent.apply(this, arguments);
      }

      return sendEvent;
    }()
    /**
     * sendReaction - Send a reaction about a message
     *
     * @param {string} messageID the message id
     * @param {object} reaction the reaction object for instance {type: 'love'}
     *
     * @return {object} The Server Response
     */

  }, {
    key: "sendReaction",
    value: function () {
      var _sendReaction = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(messageID, reaction) {
        var body, data;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (messageID) {
                  _context4.next = 2;
                  break;
                }

                throw Error("Message id is missing");

              case 2:
                if (!(!reaction || Object.keys(reaction).length === 0)) {
                  _context4.next = 4;
                  break;
                }

                throw Error("Reaction object is missing");

              case 4:
                body = {
                  reaction: reaction
                };
                _context4.next = 7;
                return this.client.post(this.client.baseURL + "/messages/".concat(messageID, "/reaction"), body);

              case 7:
                data = _context4.sent;
                return _context4.abrupt("return", data);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function sendReaction(_x3, _x4) {
        return _sendReaction.apply(this, arguments);
      }

      return sendReaction;
    }()
    /**
     * deleteReaction - Delete a reaction by user and type
     *
     * @param {string} messageID the id of the message from which te remove the reaction
     * @param {string} reactionType the type of reaction that should be removed
     *
     * @return {object} The Server Response
     */

  }, {
    key: "deleteReaction",
    value: function deleteReaction(messageID, reactionType) {
      this._checkInitialized();

      if (!reactionType || !messageID) {
        throw Error('Deleting a reaction requires specifying both the message and reaction type');
      }

      var url = this.client.baseURL + "/messages/".concat(messageID, "/reaction/").concat(reactionType);
      return this.client.delete(url);
    }
    /**
     * update - Edit the channel's custom properties
     *
     * @param {object} custom The object to update the custom properties of this channel with
     *
     * @return {type} The server response
     */

  }, {
    key: "update",
    value: function () {
      var _update = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee5(channelData, updateMessage) {
        var data;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.client.post(this._channelURL(), {
                  message: updateMessage,
                  data: channelData
                });

              case 2:
                data = _context5.sent;
                this.data = data.channel;
                return _context5.abrupt("return", data);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function update(_x5, _x6) {
        return _update.apply(this, arguments);
      }

      return update;
    }()
    /**
     * delete - Delete the channel.. Messages are permanently removed.
     *
     * @return {object} The server response
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee6() {
        var data;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.client.delete(this._channelURL());

              case 2:
                data = _context6.sent;
                return _context6.abrupt("return", data);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _delete() {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * truncate - Removes all messages from the channel
     *
     * @return {object} The server response
     */

  }, {
    key: "truncate",
    value: function () {
      var _truncate = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee7() {
        var data;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.client.post(this._channelURL() + '/truncate');

              case 2:
                data = _context7.sent;
                return _context7.abrupt("return", data);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function truncate() {
        return _truncate.apply(this, arguments);
      }

      return truncate;
    }()
  }, {
    key: "acceptInvite",
    value: function () {
      var _acceptInvite = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee8() {
        var options,
            data,
            _args8 = arguments;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                options = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                _context8.next = 3;
                return this.client.post(this._channelURL(), _objectSpread({
                  accept_invite: true
                }, options));

              case 3:
                data = _context8.sent;
                this.data = data.channel;
                return _context8.abrupt("return", data);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function acceptInvite() {
        return _acceptInvite.apply(this, arguments);
      }

      return acceptInvite;
    }()
  }, {
    key: "rejectInvite",
    value: function () {
      var _rejectInvite = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee9() {
        var options,
            data,
            _args9 = arguments;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                options = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {};
                _context9.next = 3;
                return this.client.post(this._channelURL(), _objectSpread({
                  reject_invite: true
                }, options));

              case 3:
                data = _context9.sent;
                this.data = data.channel;
                return _context9.abrupt("return", data);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function rejectInvite() {
        return _rejectInvite.apply(this, arguments);
      }

      return rejectInvite;
    }()
  }, {
    key: "addMembers",
    value: function () {
      var _addMembers = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee10(members) {
        var data;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.client.post(this._channelURL(), {
                  add_members: members
                });

              case 2:
                data = _context10.sent;
                this.data = data.channel;
                return _context10.abrupt("return", data);

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function addMembers(_x7) {
        return _addMembers.apply(this, arguments);
      }

      return addMembers;
    }()
  }, {
    key: "addModerators",
    value: function () {
      var _addModerators = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee11(members) {
        var data;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.client.post(this._channelURL(), {
                  add_moderators: members
                });

              case 2:
                data = _context11.sent;
                this.data = data.channel;
                return _context11.abrupt("return", data);

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function addModerators(_x8) {
        return _addModerators.apply(this, arguments);
      }

      return addModerators;
    }()
  }, {
    key: "removeMembers",
    value: function () {
      var _removeMembers = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee12(members) {
        var data;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.client.post(this._channelURL(), {
                  remove_members: members
                });

              case 2:
                data = _context12.sent;
                this.data = data.channel;
                return _context12.abrupt("return", data);

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function removeMembers(_x9) {
        return _removeMembers.apply(this, arguments);
      }

      return removeMembers;
    }()
  }, {
    key: "demoteModerators",
    value: function () {
      var _demoteModerators = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee13(members) {
        var data;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.client.post(this._channelURL(), {
                  demote_moderators: members
                });

              case 2:
                data = _context13.sent;
                this.data = data.channel;
                return _context13.abrupt("return", data);

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function demoteModerators(_x10) {
        return _demoteModerators.apply(this, arguments);
      }

      return demoteModerators;
    }()
  }, {
    key: "sendAction",
    value: function sendAction(messageID, formData) {
      this._checkInitialized();

      if (!messageID) {
        throw Error("Message id is missing");
      }

      return this.client.post(this.client.baseURL + "/messages/".concat(messageID, "/action"), {
        message_id: messageID,
        form_data: formData,
        id: this.id,
        type: this.type
      });
    }
    /**
     * keystroke - First of the typing.start and typing.stop events based on the users keystrokes.
     *  Call this on every keystroke
     */

  }, {
    key: "keystroke",
    value: function () {
      var _keystroke = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee14() {
        var now, diff;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (this.getConfig().typing_events) {
                  _context14.next = 2;
                  break;
                }

                return _context14.abrupt("return");

              case 2:
                now = new Date();
                diff = now - this.lastTypingEvent;
                this.lastKeyStroke = now;
                this.isTyping = true; // send a typing.start every 2 seconds

                if (!(diff > 2000)) {
                  _context14.next = 10;
                  break;
                }

                this.lastTypingEvent = new Date();
                _context14.next = 10;
                return this.sendEvent({
                  type: 'typing.start'
                });

              case 10:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function keystroke() {
        return _keystroke.apply(this, arguments);
      }

      return keystroke;
    }()
    /**
     * stopTyping - Sets last typing to null and sends the typing.stop event
     */

  }, {
    key: "stopTyping",
    value: function () {
      var _stopTyping = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee15() {
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (this.getConfig().typing_events) {
                  _context15.next = 2;
                  break;
                }

                return _context15.abrupt("return");

              case 2:
                this.lastTypingEvent = null;
                this.isTyping = false;
                _context15.next = 6;
                return this.sendEvent({
                  type: 'typing.stop'
                });

              case 6:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function stopTyping() {
        return _stopTyping.apply(this, arguments);
      }

      return stopTyping;
    }()
    /**
     * lastMessage - return the last message, takes into account that last few messages might not be perfectly sorted
     *
     * @return {type} Description
     */

  }, {
    key: "lastMessage",
    value: function lastMessage() {
      // get last 5 messages, sort, return the latest
      // get a slice of the last 5
      var min = this.state.messages.length - 5;

      if (min < 0) {
        min = 0;
      }

      var max = this.state.messages.length + 1;
      var messageSlice = this.state.messages.slice(min, max).asMutable(); // sort by pk desc

      messageSlice.sort(function (a, b) {
        return b.created_at - a.created_at;
      });
      var lastMessage;

      if (messageSlice.length > 0) {
        lastMessage = messageSlice[0];
      }

      return lastMessage;
    }
    /**
     * markRead - Send the mark read event for this user, only works if the `read_events` setting is enabled
     *
     * @return {Promise} Description
     */

  }, {
    key: "markRead",
    value: function markRead() {
      this._checkInitialized();

      if (!this.getConfig().read_events) {
        return Promise.resolve(null);
      }

      var lastMessage = this.lastMessage();
      var lastMessageCreatedAt, lastMessageID;

      if (lastMessage) {
        lastMessageCreatedAt = lastMessage.created_at;
        lastMessageID = lastMessage.id;
      }

      return this.sendEvent({
        type: 'message.read',
        lastMessageID: lastMessageID,
        lastMessageCreatedAt: lastMessageCreatedAt
      });
    }
    /**
     * clean - Cleans the channel state and fires stop typing if needed
     */

  }, {
    key: "clean",
    value: function clean() {
      if (this.lastKeyStroke) {
        var now = new Date();
        var diff = now - this.lastKeyStroke;

        if (diff > 1000 && this.isTyping) {
          logChatPromiseExecution(this.stopTyping(), 'stop typing event');
        }
      }

      this.state.clean();
    }
    /**
     * watch - Loads the initial channel state and watches for changes
     *
     * @param {object} options additional options for the query endpoint
     *
     * @return {object} The server response
     */

  }, {
    key: "watch",
    value: function () {
      var _watch = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee16(options) {
        var defaultOptions, combined, state;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                defaultOptions = {
                  state: true,
                  watch: true,
                  presence: false
                };

                if (!this.client._hasClientID()) {
                  defaultOptions.watch = false;
                }

                combined = _objectSpread({}, defaultOptions, options);
                _context16.next = 5;
                return this.query(combined);

              case 5:
                state = _context16.sent;
                this.initialized = true;

                this._initializeState(state);

                return _context16.abrupt("return", state);

              case 9:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function watch(_x11) {
        return _watch.apply(this, arguments);
      }

      return watch;
    }()
    /**
     * stopwatching - Stops watching the channel
     *
     * @return {object} The server response
     */

  }, {
    key: "stopWatching",
    value: function () {
      var _stopWatching = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee17() {
        var response;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.client.post(this._channelURL() + '/stop-watching', {});

              case 2:
                response = _context17.sent;
                return _context17.abrupt("return", response);

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function stopWatching() {
        return _stopWatching.apply(this, arguments);
      }

      return stopWatching;
    }()
    /**
     * getReplies - Description
     *
     * @param {type} parent_id The message parent id, ie the top of the thread
     * @param {type} options   Pagination params, ie {limit:10, idlte: 10}
     *
     * @return {type} A response with a list of messages
     */

  }, {
    key: "getReplies",
    value: function () {
      var _getReplies = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee18(parent_id, options) {
        var data;
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.client.get(this.client.baseURL + "/messages/".concat(parent_id, "/replies"), _objectSpread({}, options));

              case 2:
                data = _context18.sent;

                // add any messages to our thread state
                if (data.messages) {
                  this.state.addMessagesSorted(data.messages);
                }

                return _context18.abrupt("return", data);

              case 5:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getReplies(_x12, _x13) {
        return _getReplies.apply(this, arguments);
      }

      return getReplies;
    }()
    /**
     * getReactions - List the reactions, supports pagination
     *
     * @param {string} message_id The message id
     * @param {object} options    The pagination options
     *
     * @return {object} Server response
     */

  }, {
    key: "getReactions",
    value: function () {
      var _getReactions = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee19(message_id, options) {
        var data;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.client.get(this.client.baseURL + "/messages/".concat(message_id, "/reactions"), _objectSpread({}, options));

              case 2:
                data = _context19.sent;
                return _context19.abrupt("return", data);

              case 4:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getReactions(_x14, _x15) {
        return _getReactions.apply(this, arguments);
      }

      return getReactions;
    }()
    /**
     * countUnread - Count the number of messages with a date thats newer than the last read timestamp
     *
     * @param {date} lastRead the time that the user read a message
     *
     * @return {int} Unread count
     */

  }, {
    key: "countUnread",
    value: function countUnread(lastRead) {
      var count = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.state.messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var m = _step.value;

          if (m.created_at > lastRead) {
            count++;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return count;
    }
    /**
     * create - Description
     *
     * @return {type} Description
     */

  }, {
    key: "query",

    /**
     * query - Query the API, get messages, members or other channel fields
     *
     * @param {object} options The query options
     *
     * @return {object} Returns a query response
     */
    value: function () {
      var _query = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee20(options) {
        var queryURL, state;
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return Promise.resolve(this.client.wsPromise);

              case 2:
                queryURL = "".concat(this.client.baseURL, "/channels/").concat(this.type);

                if (this.id) {
                  queryURL += "/".concat(this.id);
                }

                _context20.next = 6;
                return this.client.post(queryURL + '/query', _objectSpread({
                  data: this._data,
                  state: true
                }, options));

              case 6:
                state = _context20.sent;

                // update the channel id if it was missing
                if (!this.id) {
                  this.id = state.channel.id;
                  this.cid = state.channel.cid; // set the channel as active...

                  if (!(this.cid in this.client.activeChannels)) {
                    this.client.activeChannels[this.cid] = this;
                  }
                }

                this.client._addChannelConfig(state); // add any messages to our channel state


                this._initializeState(state);

                return _context20.abrupt("return", state);

              case 11:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function query(_x16) {
        return _query.apply(this, arguments);
      }

      return query;
    }()
    /**
     * banUser - Bans a user from a channel
     *
     * @param targetUserID
     * @param options
     * @returns {Promise<*>}
     */

  }, {
    key: "banUser",
    value: function () {
      var _banUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee21(targetUserID, options) {
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this._checkInitialized();

                _context21.next = 3;
                return this.client.banUser(targetUserID, _objectSpread({}, options, {
                  type: this.type,
                  id: this.id
                }));

              case 3:
                return _context21.abrupt("return", _context21.sent);

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function banUser(_x17, _x18) {
        return _banUser.apply(this, arguments);
      }

      return banUser;
    }()
    /**
     * banUser - Removes the bans for a user on a channel
     *
     * @param targetUserID
     * @returns {Promise<*>}
     */

  }, {
    key: "unbanUser",
    value: function () {
      var _unbanUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee22(targetUserID) {
        return _regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this._checkInitialized();

                _context22.next = 3;
                return this.client.unbanUser(targetUserID, {
                  type: this.type,
                  id: this.id
                });

              case 3:
                return _context22.abrupt("return", _context22.sent);

              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function unbanUser(_x19) {
        return _unbanUser.apply(this, arguments);
      }

      return unbanUser;
    }()
    /**
     * on - Listen to events on this channel.
     *
     * channel.on('message.new', event => {console.log("my new message", event, channel.state.messages)})
     * or
     * channel.on(event => {console.log(event.type)})
     *
     * @param {string} callbackOrString  The event type to listen for (optional)
     * @param {function} callbackOrNothing The callback to call
     *
     * @return {type} Description
     */

  }, {
    key: "on",
    value: function on(callbackOrString, callbackOrNothing) {
      var key = callbackOrNothing ? callbackOrString : 'all';
      var valid = isValidEventType(key);

      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }

      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;

      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }

      this.listeners[key].push(callback);
    }
    /**
     * off - Remove the event handler
     *
     */

  }, {
    key: "off",
    value: function off(callbackOrString, callbackOrNothing) {
      this._checkInitialized();

      var key = callbackOrNothing ? callbackOrString : 'all';
      var valid = isValidEventType(key);

      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }

      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;

      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }

      this.listeners[key] = this.listeners[key].filter(function (value) {
        return value !== callback;
      });
    }
  }, {
    key: "_handleChannelEvent",
    value: function _handleChannelEvent(event) {
      var channel = this;
      var messageUpdateEvent = {
        'message.updated': true,
        'message.deleted': true,
        'message.reaction': true
      };
      var s = channel.state;

      if (event.type === 'typing.start') {
        s.typing = s.typing.set(event.user.id, Immutable(event));
      } else if (event.type === 'typing.stop') {
        s.typing = s.typing.without(event.user.id);
      } else if (event.type === 'message.read') {
        s.read = s.read.set(event.user.id, Immutable(event));
      } else if (event.type === 'user.watching.start' || event.types === 'user.updated') {
        s.watchers = s.watchers.set(event.user.id, Immutable(event.user));
      } else if (event.type === 'user.watching.stop') {
        s.watchers = s.watchers.without(event.user.id);
      } else if (event.type === 'message.new') {
        s.addMessageSorted(event.message);
      } else if (event.type in messageUpdateEvent) {
        s.addMessageSorted(event.message);
      } else if (event.type === 'member.added' || event.type === 'member.updated') {
        s.members = s.members.set(event.member.id, Immutable(event.member));
      } else if (event.type === 'member.removed') {
        s.members = s.members.without(event.user.id);
      } else if (event.type === 'channel.updated') {
        channel.data = Immutable(event.channel);
      } // any event can send over the online count


      if (event.watcher_count !== undefined) {
        channel.state.watcher_count = event.watcher_count;
      } // gather and call the listeners


      var listeners = [];

      if (channel.listeners.all) {
        listeners.push.apply(listeners, _toConsumableArray(channel.listeners.all));
      }

      if (channel.listeners[event.type]) {
        listeners.push.apply(listeners, _toConsumableArray(channel.listeners[event.type]));
      } // call the event and send it to the listeners


      for (var _i = 0; _i < listeners.length; _i++) {
        var listener = listeners[_i];
        listener(event);
      }
    }
    /**
     * _channelURL - Returns the channel url
     *
     * @return {string} The channel url
     */

  }, {
    key: "_checkInitialized",
    value: function _checkInitialized() {
      if (!this.initialized && !this.client._isUsingServerAuth()) {
        throw Error("Channel ".concat(this.cid, " hasn't been initialized yet. Make sure to call .watch() and wait for it to resolve"));
      }
    }
  }, {
    key: "_initializeState",
    value: function _initializeState(state) {
      // immutable list of maps
      var messages = state.messages || [];

      if (!this.state.messages) {
        this.state.messages = Immutable([]);
      }

      this.state.addMessagesSorted(messages);
      this.state.watcher_count = state.watcher_count; // convert the arrays into objects for easier syncing...

      if (state.watchers) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = state.watchers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var watcher = _step2.value;
            this.state.watchers = this.state.watchers.set(watcher.id, watcher);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      if (state.read) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = state.read[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var read = _step3.value;
            this.state.read = this.state.read.set(read.user.id, read);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      if (state.members) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = state.members[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var m = _step4.value;
            this.state.members = this.state.members.set(m.id, m);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    }
  }]);

  return Channel;
}();

/**
 * ClientState - A container class for the client state.
 */

var ClientState =
/*#__PURE__*/
function () {
  function ClientState() {
    _classCallCheck(this, ClientState);

    // show the status for a certain user...
    // ie online, offline etc
    this.users = Immutable({});
  }

  _createClass(ClientState, [{
    key: "updateUser",
    value: function updateUser(user) {
      if (user != null) {
        this.users = this.users.set(user.id, Immutable(user));
      }
    }
  }]);

  return ClientState;
}();

/**
 * StableWSConnection - A WS connection that reconnects upon failure.
 * - the browser will sometimes report that you're online or offline
 * - the WS connection can break and fail (there is a 30s health check)
 * - sometimes your WS connection will seem to work while the user is in fact offline
 * - to speed up online/offline detection you can use the window.addEventListener('offline');
 *
 * There are 4 ways in which a connection can become unhealthy:
 * - websocket.onerror is called
 * - websocket.onclose is called
 * - the health check fails and no event is received for ~40 seconds
 * - the browser indicates the connection is now offline
 *
 * There are 2 assumptions we make about the server:
 * - state can be recovered by querying the channel again
 * - if the servers fails to publish a message to the client, the WS connection is destroyed
 */

var StableWSConnection =
/*#__PURE__*/
function () {
  function StableWSConnection(_ref) {
    var _this = this;

    var wsURL = _ref.wsURL,
        clientID = _ref.clientID,
        userID = _ref.userID,
        messageCallback = _ref.messageCallback,
        recoverCallback = _ref.recoverCallback,
        eventCallback = _ref.eventCallback;

    _classCallCheck(this, StableWSConnection);

    _defineProperty(this, "onlineStatusChanged", function (event) {
      if (event.type === 'offline') {
        // mark the connection as down
        _this._setHealth(false);
      } else if (event.type === 'online') {
        // retry right now...
        // We check this.isHealthy, not sure if it's always
        // smart to create a new WS connection if the old one is still up and running.
        // it's possible we didnt miss any messages, so this process is just expensive and not needed.
        if (!_this.isHealthy) {
          _this._reconnect(10);
        }
      }
    });

    _defineProperty(this, "onopen", function (wsID) {
      if (_this.wsID !== wsID) return; // set healthy..

      _this._setHealth(true);
    });

    _defineProperty(this, "onmessage", function (wsID, event) {
      if (_this.wsID !== wsID) return; // we wait till the first message before we consider the connection open..
      // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately
      // after that a ws.onclose..

      if (!_this.isResolved) {
        _this.resolvePromise(event);
      } // trigger the event..


      _this.lastEvent = new Date();

      _this.messageCallback(event);
    });

    _defineProperty(this, "onclose", function (wsID, event) {
      if (_this.wsID !== wsID) return;

      if (event.code === 1000) {
        // this is a permanent error raised by stream..
        // usually caused by invalid auth details
        var error = new Error("WS connection reject with error ".concat(event.reason));
        error.reason = event.reason;

        _this.rejectPromise(error);
      } else {
        _this.consecutiveFailures += 1;
        _this.totalFailures += 1;

        _this._setHealth(false);

        _this.rejectPromise(_this._errorFromWSEvent(event)); // reconnect if its an abnormal failure


        _this._reconnect();
      }
    });

    _defineProperty(this, "onerror", function (wsID, event) {
      if (_this.wsID !== wsID) return;
      _this.consecutiveFailures += 1;
      _this.totalFailures += 1;

      _this._setHealth(false);

      _this.rejectPromise(_this._errorFromWSEvent(event));

      _this._reconnect();
    });

    _defineProperty(this, "_setHealth", function (healthy) {
      if (healthy && !_this.isHealthy) {
        // yee we are online:
        _this.isHealthy = true;

        _this.eventCallback({
          type: 'connection.changed',
          online: true
        });
      }

      if (!healthy && _this.isHealthy) {
        // bummer we are offline
        _this.isHealthy = false;

        _this.eventCallback({
          type: 'connection.changed',
          online: false
        });
      }
    });

    _defineProperty(this, "_errorFromWSEvent", function (event) {
      var error = new Error("WS failed with code ".concat(event.code));
      error.code = event.code;
      error.isWSFailure = true;
      return error;
    });

    _defineProperty(this, "_listenForConnectionChanges", function () {
      if (typeof window !== 'undefined' && window != null && window.addEventListener != null) {
        window.addEventListener('offline', _this.onlineStatusChanged);
        window.addEventListener('online', _this.onlineStatusChanged);
      }
    });

    _defineProperty(this, "_removeConnectionListeners", function () {
      if (typeof window !== 'undefined' && window != null && window.addEventListener != null) {
        window.removeEventListener('offline', _this.onlineStatusChanged);
        window.removeEventListener('online', _this.onlineStatusChanged);
      }
    });

    _defineProperty(this, "_setupConnectionPromise", function () {
      var that = _this;
      _this.isResolved = false;
      /** a promise that is resolved once ws.open is called */

      _this.connectionOpen = new Promise(function (resolve, reject) {
        that.resolvePromise = resolve;
        that.rejectPromise = reject;
      }).then(function (e) {
        var data = JSON.parse(e.data);

        if (data.error != null) {
          throw new Error(JSON.stringify(data.error));
        }

        return data;
      });
    });

    this.wsURL = wsURL;
    this.clientID = clientID;
    this.userID = userID;
    /** consecutive failures influence the duration of the timeout */

    this.consecutiveFailures = 0;
    /** keep track of the total number of failures */

    this.totalFailures = 0;
    /** We only make 1 attempt to reconnect at the same time.. */

    this.isConnecting = false;
    /** Boolean that indicates if we have a working connection to the server */

    this.isHealthy = false;
    /** Callback when the connection fails and recovers */

    this.recoverCallback = recoverCallback;
    this.messageCallback = messageCallback;
    this.eventCallback = eventCallback;
    /** Incremented when a new WS connection is made */

    this.wsID = 1;
    /** Store the last event time for health checks */

    this.lastEvent = null;
    /** Send a health check message every 30 seconds */

    this.healthCheckInterval = 30 * 1000;
    /** Every second we verify that we didn't miss any health checks */

    this.monitorInterval = 1 * 1000;

    this._listenForConnectionChanges();
  }
  /**
   * connect - Connect to the WS URL
   *
   * @return {promise} Promise that completes once the first health check message is received
   */


  _createClass(StableWSConnection, [{
    key: "connect",
    value: function () {
      var _connect2 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        var healthCheck;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.isConnecting) {
                  _context.next = 2;
                  break;
                }

                throw Error("You've called connect twice, can only attempt 1 connection at the time");

              case 2:
                _context.prev = 2;
                this.isConnecting = true;
                _context.next = 6;
                return this._connect();

              case 6:
                healthCheck = _context.sent;
                this.isConnecting = false;
                this.consecutiveFailures = 0;

                this._startMonitor();

                this._startHealthCheck();

                return _context.abrupt("return", healthCheck);

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](2);
                // This is a permanent failure, throw the error...
                this.isConnecting = false;

                if (_context.t0.isWSFailure) {
                  _context.next = 19;
                  break;
                }

                throw _context.t0;

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 14]]);
      }));

      function connect() {
        return _connect2.apply(this, arguments);
      }

      return connect;
    }()
    /**
     * disconnect - Disconnect the connection and doesn't recover...
     *
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      // start by removing all the listeners
      if (this.healthCheckIntervalRef) {
        clearInterval(this.healthCheckIntervalRef);
      }

      if (this.monitorIntervalRef) {
        clearInterval(this.monitorIntervalRef);
      }

      this._removeConnectionListeners(); // reset the wsID;


      this.wsID = 1;
      this.isHealthy = false; // remove ws handlers...

      if (this.ws && this.ws.removeAllListeners) {
        this.ws.removeAllListeners();
      } // and finally close...


      if (this.ws && this.ws.close) {
        this.ws.close(1000, 'Manually closed connection by calling client.disconnect()');
      }

      delete this.ws;
    }
    /**
     * _connect - Connect to the WS endpoint
     *
     * @return {promise} Promise that completes once the first health check message is received
     */

  }, {
    key: "_connect",
    value: function _connect() {
      this._setupConnectionPromise();

      this.ws = new isoWS(this.wsURL);
      this.ws.onopen = this.onopen.bind(this, this.wsID);
      this.ws.onclose = this.onclose.bind(this, this.wsID);
      this.ws.onerror = this.onerror.bind(this, this.wsID);
      this.ws.onmessage = this.onmessage.bind(this, this.wsID);
      return this.connectionOpen;
    }
    /**
     * _reconnect - Description
     *
     * @param {int} interval number of ms to wait before connecting
     */

  }, {
    key: "_reconnect",
    value: function () {
      var _reconnect2 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(interval) {
        var open;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this.isConnecting || this.isHealthy)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                this.isConnecting = true; // reconnect in case of on error or on close
                // also reconnect if the health check cycle fails

                if (interval === undefined) {
                  interval = this._retryInterval();
                } // cleanup the old connection


                this._destroyCurrentWSConnection(); // reconnect, or try again after a little while...


                _context2.next = 7;
                return sleep(interval);

              case 7:
                _context2.prev = 7;
                _context2.next = 10;
                return this._connect();

              case 10:
                open = _context2.sent;

                if (!this.recoverCallback) {
                  _context2.next = 14;
                  break;
                }

                _context2.next = 14;
                return this.recoverCallback(open);

              case 14:
                this.isConnecting = false;
                this.consecutiveFailures = 0;
                _context2.next = 23;
                break;

              case 18:
                _context2.prev = 18;
                _context2.t0 = _context2["catch"](7);
                this.isConnecting = false;
                console.warn("reconnect failed with error", _context2.t0); // reconnect on WS failures, dont reconnect if there is a code bug

                if (_context2.t0.isWSFailure) {
                  this._reconnect();
                }

              case 23:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[7, 18]]);
      }));

      function _reconnect(_x) {
        return _reconnect2.apply(this, arguments);
      }

      return _reconnect;
    }()
    /**
     * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.
     *
     * @param {object} event Event with type online or offline
     *
     */

  }, {
    key: "_destroyCurrentWSConnection",

    /**
     * _destroyCurrentWSConnection - Removes the current WS connnection
     *
     */
    value: function _destroyCurrentWSConnection() {
      // increment the ID, meaning we will ignore all messages from the old
      // ws connection from now on.
      this.wsID += 1;

      try {
        if (this.ws && this.ws.removeAllListeners) {
          this.ws.removeAllListeners();
        }

        if (this.ws && this.ws.close) {
          this.ws.close();
        }
      } catch (e) {// we dont care
      }
    }
    /**
     * _retryInterval - A retry interval which increases after consecutive failures
     *
     * @return {int} Duration to wait in milliseconds
     */

  }, {
    key: "_retryInterval",
    value: function _retryInterval() {
      // try to reconnect in 0-5 seconds (random to spread out the load from failures)
      var max = this.consecutiveFailures * 5000;

      if (max > 25000) {
        max = 25000;
      }

      var min = (this.consecutiveFailures - 1) * 5000;
      var interval = Math.round(Math.random() * (max - min) + min);

      if (interval < 1000) {
        interval = 1000;
      }

      return interval;
    }
    /**
     * _setupPromise - sets up the this.connectOpen promise
     */

  }, {
    key: "_startHealthCheck",

    /**
     * _startHealthCheck - Sends a message every 30s or so to see if the ws connection still works
     *
     */
    value: function _startHealthCheck() {
      var that = this; // 30 seconds is the recommended interval (messenger uses this)

      this.healthCheckIntervalRef = setInterval(function () {
        // send the healthcheck.., server replies with a health check event
        var data = [{
          type: 'health.check',
          clientID: that.clientID,
          userID: that.userID
        }]; // try to send on the connection

        try {
          that.ws.send(JSON.stringify(data));
        } catch (e) {// error will already be detected elsewhere
        }
      }, that.healthCheckInterval);
    }
    /**
     * _startMonitor - Verifies we didn't miss any events. Marks the connection as failed in case we did.
     *
     */

  }, {
    key: "_startMonitor",
    value: function _startMonitor() {
      var _this2 = this;

      var that = this;
      this.monitorIntervalRef = setInterval(function () {
        var now = new Date(); // means we missed a health check

        if (now - that.lastEvent > _this2.healthCheckInterval + 10 * 1000) {
          that._setHealth(false);

          that._reconnect();
        }
      }, that.monitorInterval);
    }
  }]);

  return StableWSConnection;
}();

var jwt = null;

var crypto = null;

/**
 * Creates the JWT token that can be used for a UserSession
 * @method JWTUserSessionToken
 * @memberof signing
 * @private
 * @param {string} apiSecret - API Secret key
 * @param {string} userId - The user_id key in the JWT payload
 * @param {object} [extraData] - Extra that should be part of the JWT token
 * @param {object} [jwtOptions] - Options that can be past to jwt.sign
 * @return {string} JWT Token
 */

function JWTUserToken(apiSecret, userId) {
  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var jwtOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (typeof userId !== 'string') {
    throw new TypeError('userId should be a string');
  }

  var payload = _objectSpread({
    user_id: userId
  }, extraData);

  var opts = _extends({
    algorithm: 'HS256',
    noTimestamp: true
  }, jwtOptions);

  return jwt.sign(payload, apiSecret, opts);
}
function JWTServerToken(apiSecret) {
  var jwtOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var payload = {
    server: true
  };

  var opts = _extends({
    algorithm: 'HS256',
    noTimestamp: true
  }, jwtOptions);

  return jwt.sign(payload, apiSecret, opts);
}

function decodeBase64(s) {
  var e = {},
      w = String.fromCharCode,
      L = s.length;
  var i,
      b = 0,
      c,
      x,
      l = 0,
      a,
      r = '';
  var A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (i = 0; i < 64; i++) {
    e[A.charAt(i)] = i;
  }

  for (x = 0; x < L; x++) {
    c = e[s.charAt(x)];
    b = (b << 6) + c;
    l += 6;

    while (l >= 8) {
      ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));
    }
  }

  return r;
}
/**
 * @return {string}
 */


function UserFromToken(token) {
  var fragments = token.split('.');

  if (fragments.length !== 3) {
    return '';
  }

  var b64Payload = fragments[1];
  var payload = decodeBase64(b64Payload);
  var data = JSON.parse(payload);
  return data.user_id;
}

function encodeBase64(s) {
  if (typeof window !== 'undefined' && window.btoa) {
    return window.btoa(s);
  } else {
    return Buffer.from(s.toString(), 'binary').toString('base64');
  }
}
/**
 *
 * @param userId {string} the id of the user
 * @return {string}
 */


function DevToken(userId) {
  return ['eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9', //{"alg": "HS256", "typ": "JWT"}
  encodeBase64(JSON.stringify({
    user_id: userId
  })), 'devtoken'].join('.');
}
/**
 *
 * @param body {string} the signed message
 * @param secret {string} the shared secret used to generate the signature (Stream API secret)
 * @param signature {string} the signature to validate
 * @return {boolean}
 */

function CheckSignature(body, secret, signature) {
  var key = new Buffer(secret, 'ascii');
  var hash = crypto.createHmac('sha256', key).update(body).digest('hex');
  return hash === signature;
}

var http = null;

var https = null;

function isReadableStream(obj) {
  return _typeof(obj) === 'object' && _typeof(obj._read === 'function') && _typeof(obj._readableState === 'object');
}

var StreamChat =
/*#__PURE__*/
function () {
  function StreamChat(key, secretOrOptions, options) {
    var _this = this;

    _classCallCheck(this, StreamChat);

    _defineProperty(this, "_hasClientID", function () {
      var hasClient = !!_this.clientID;
      return hasClient;
    });

    _defineProperty(this, "dispatchEvent", function (event) {
      // client event handlers
      _this._handleClientEvent(event); // channel event handlers


      var cid = event.cid;
      var channel = _this.activeChannels[cid];

      if (channel) {
        channel._handleChannelEvent(event);
      }
    });

    _defineProperty(this, "handleEvent", function (messageEvent) {
      // dispatch the event to the channel listeners
      var jsonString = messageEvent.data;
      var event = JSON.parse(jsonString);
      event.received_at = new Date();

      _this.dispatchEvent(event);
    });

    _defineProperty(this, "recoverState",
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee() {
      var cids, lastMessageIDs, _arr, _i, c, lastMessage, lastMessageId;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cids = Object.keys(_this.activeChannels || {});
              lastMessageIDs = {};
              _arr = Object.values(_this.activeChannels);

              for (_i = 0; _i < _arr.length; _i++) {
                c = _arr[_i];
                lastMessage = c.lastMessage();
                lastMessageId = void 0;

                if (lastMessage) {
                  lastMessageId = lastMessage.id;
                }

                lastMessageIDs[c.cid] = lastMessageId;
              }

              if (!cids.length) {
                _context.next = 8;
                break;
              }

              _context.next = 7;
              return _this.queryChannels({
                cid: {
                  $in: cids
                }
              }, {
                last_message_at: -1
              }, {
                limit: 30,
                recovery: true,
                last_message_ids: lastMessageIDs
              });

            case 7:
              _this.dispatchEvent({
                type: 'connection.recovered'
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    })));

    _defineProperty(this, "_isUsingServerAuth", function () {
      // returns if were in server side mode or not...
      var serverAuth = !!_this.secret;
      return serverAuth;
    });

    // set the key
    this.key = key;
    this.userToken = null;
    this.secret = null;
    this.listeners = {};
    this.state = new ClientState(); // set the secret

    if (secretOrOptions && secretOrOptions.indexOf) {
      this.secret = secretOrOptions;
    } // set the options... and figure out defaults...


    options = options || secretOrOptions;

    if (!options) {
      options = {};
    }

    this.browser = typeof options.browser !== 'undefined' ? options.browser : typeof window !== 'undefined';
    this.node = !this.browser;
    var defaultOptions = {
      timeout: 3000
    };

    if (this.node) {
      var nodeOptions = {
        httpAgent: new http.Agent({
          keepAlive: 3000
        }),
        httpsAgent: new https.Agent({
          keepAlive: 3000
        })
      };
      this.options = _objectSpread({}, nodeOptions, defaultOptions, options);
    } else {
      this.options = _objectSpread({}, defaultOptions, options);
      delete this.options.httpAgent;
      delete this.options.httpsAgent;
    }

    this.setBaseURL('https://chat-us-east-1.stream-io-api.com');

    if (typeof process !== 'undefined' && process.env.STREAM_LOCAL_TEST_RUN) {
      this.setBaseURL('http://localhost:3030');
    } // WS connection is initialized when setUser is called


    this.wsConnection = null;
    this.wsPromise = null; // keeps a reference to all the channels that are in use

    this.activeChannels = {}; // mapping between channel groups and configs

    this.configs = {};
    this.anonymous = false;

    this._startCleaning();
  }

  _createClass(StreamChat, [{
    key: "devToken",
    value: function devToken(userID) {
      return DevToken(userID);
    }
  }, {
    key: "getAuthType",
    value: function getAuthType() {
      return this.anonymous ? 'anonymous' : 'jwt';
    }
  }, {
    key: "setBaseURL",
    value: function setBaseURL(baseURL) {
      this.baseURL = baseURL;
      this.wsBaseURL = this.baseURL.replace('http', 'ws');
    }
  }, {
    key: "_setupConnection",
    value: function _setupConnection() {
      this.UUID = uuidv4();
      this.clientID = "".concat(this.userID, "--").concat(this.UUID);
      this.connect();
      return this.wsPromise;
    }
  }, {
    key: "setUser",

    /**
     * setUser - Set the current user, this triggers a connection to the API
     *
     * @param {object} user Data about this user. IE {name: "john"}
     * @param {string} userToken   Token
     *
     * @return {promise} Returns a promise that resolves when the connection is setup
     */
    value: function setUser(user, userToken) {
      if (this.userID) {
        throw new Error('Use client.disconnect() before trying to connect as a different user. setUser was called twice.');
      } // we generate the client id client side


      this.userID = user.id;

      if (!this.userID) {
        throw new Error('The "id" field on the user is missing');
      }

      this.userToken = userToken;

      if (userToken == null && this.secret != null) {
        this.userToken = this.createToken(this.userID);
      }

      if (this.userToken == null) {
        throw new Error('both userToken and api secret are not provided');
      }

      var tokenUserId = UserFromToken(this.userToken);

      if (userToken != null && (tokenUserId == null || tokenUserId === '' || tokenUserId !== user.id)) {
        throw new Error('userToken does not have a user_id or is not matching with user.id');
      }

      this._setUser(user);

      this.anonymous = false;
      return this._setupConnection();
    }
  }, {
    key: "_setUser",
    value: function _setUser(user) {
      // this one is used by the frontend
      this.user = user; // this one is actually used for requests...

      this._user = _objectSpread({}, user);
    }
    /**
     * updateAppSettings - updates application settings
     *
     * @param {object} options App settings.
     * 		IE: {
      			"apn_config": {
    				"auth_type": "token",
    				"auth_key": fs.readFileSync(
    					'./apn-push-auth-key.p8',
    					'utf-8',
    				),
    				"key_id": "keyid",
    				"team_id": "teamid", //either ALL these 3
    				"notification_template": "notification handlebars template",
    				"bundle_id": "com.apple.your.app",
    				"development": true
    			},
    			"firebase_config": {
    				"api_key": "apiapiapi",
    				"notification_template": "notification handlebars template"
    			},
    			"webhook_url": "https://acme.com/my/awesome/webhook/"
    		}
     */

  }, {
    key: "updateAppSettings",
    value: function () {
      var _updateAppSettings = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2(options) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (options.apn_config && options.apn_config.p12_cert) {
                  options.apn_config.p12_cert = Buffer.from(options.apn_config.p12_cert).toString('base64');
                }

                _context2.next = 3;
                return this.patch(this.baseURL + '/app', options);

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function updateAppSettings(_x) {
        return _updateAppSettings.apply(this, arguments);
      }

      return updateAppSettings;
    }()
    /**
     * getAppSettings - retrieves application settings
     */

  }, {
    key: "getAppSettings",
    value: function () {
      var _getAppSettings = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.get(this.baseURL + '/app');

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAppSettings() {
        return _getAppSettings.apply(this, arguments);
      }

      return getAppSettings;
    }()
    /**
     * disconnect - closes the WS connection
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      // remove the user specific fields
      delete this.user;
      delete this._user;
      delete this.anonymous;
      delete this.userID;
      delete this.userToken;
      this.connectionEstablishedCount = 0; // close the WS connection

      if (this.wsConnection) {
        this.wsConnection.disconnect();
      }
    }
  }, {
    key: "setAnonymousUser",
    value: function setAnonymousUser() {
      this.anonymous = true;
      this.userID = uuidv4();

      this._setUser({
        id: this.userID,
        anon: true
      });

      return this._setupConnection();
    }
    /**
     * setGuestUser - Setup a temporary guest user
     *
     * @param {object} user Data about this user. IE {name: "john"}
     *
     * @return {promise} Returns a promise that resolves when the connection is setup
     */

  }, {
    key: "setGuestUser",
    value: function () {
      var _setGuestUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(user) {
        var response, _response$user, created_at, updated_at, last_active, online, guestUser;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.anonymous = true;
                _context4.prev = 1;
                _context4.next = 4;
                return this.post(this.baseURL + '/guest', {
                  user: user
                });

              case 4:
                response = _context4.sent;
                _context4.next = 11;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](1);
                this.anonymous = false;
                throw _context4.t0;

              case 11:
                this.anonymous = false;
                _response$user = response.user, created_at = _response$user.created_at, updated_at = _response$user.updated_at, last_active = _response$user.last_active, online = _response$user.online, guestUser = _objectWithoutProperties(_response$user, ["created_at", "updated_at", "last_active", "online"]);
                _context4.next = 15;
                return this.setUser(guestUser, response.access_token);

              case 15:
                return _context4.abrupt("return", _context4.sent);

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 7]]);
      }));

      function setGuestUser(_x2) {
        return _setGuestUser.apply(this, arguments);
      }

      return setGuestUser;
    }()
    /**
     * createToken - Creates a token to authenticate this user. This function is used server side.
     * The resulting token should be passed to the client side when the users registers or logs in
     *
     * @param {string}   userID         The User ID
     * @param {string}   exp            The expiration time for the token expressed in the number of seconds since the epoch
     *
     * @return {string} Returns a token
     */

  }, {
    key: "createToken",
    value: function createToken(userID, exp) {
      var extra = {};

      if (exp != null) {
        extra.exp = exp;
      }

      return JWTUserToken(this.secret, userID, extra, {});
    }
    /**
     * on - Listen to events on all channels and users your watching
     *
     * client.on('message.new', event => {console.log("my new message", event, channel.state.messages)})
     * or
     * client.on(event => {console.log(event.type)})
     *
     * @param {string} callbackOrString  The event type to listen for (optional)
     * @param {function} callbackOrNothing The callback to call
     *
     * @return {type} Description
     */

  }, {
    key: "on",
    value: function on(callbackOrString, callbackOrNothing) {
      var key = callbackOrNothing ? callbackOrString : 'all';
      var valid = isValidEventType(key);

      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }

      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;

      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }

      this.listeners[key].push(callback);
    }
    /**
     * off - Remove the event handler
     *
     */

  }, {
    key: "off",
    value: function off(callbackOrString, callbackOrNothing) {
      var key = callbackOrNothing ? callbackOrString : 'all';
      var valid = isValidEventType(key);

      if (!valid) {
        throw Error("Invalid event type ".concat(key));
      }

      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;

      if (!(key in this.listeners)) {
        this.listeners[key] = [];
      }

      this.listeners[key] = this.listeners[key].filter(function (value) {
        return value !== callback;
      });
    }
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee5(url, params) {
        var response;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                _context5.next = 3;
                return axios.get(url, this._addClientParams(params));

              case 3:
                response = _context5.sent;
                return _context5.abrupt("return", this.handleResponse(response));

              case 7:
                _context5.prev = 7;
                _context5.t0 = _context5["catch"](0);

                if (!_context5.t0.response) {
                  _context5.next = 13;
                  break;
                }

                return _context5.abrupt("return", this.handleResponse(_context5.t0.response));

              case 13:
                throw _context5.t0;

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[0, 7]]);
      }));

      function get(_x3, _x4) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "put",
    value: function () {
      var _put = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee6(url, data) {
        var response;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return axios.put(url, data, this._addClientParams());

              case 3:
                response = _context6.sent;
                return _context6.abrupt("return", this.handleResponse(response));

              case 7:
                _context6.prev = 7;
                _context6.t0 = _context6["catch"](0);

                if (!_context6.t0.response) {
                  _context6.next = 13;
                  break;
                }

                return _context6.abrupt("return", this.handleResponse(_context6.t0.response));

              case 13:
                throw _context6.t0;

              case 14:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 7]]);
      }));

      function put(_x5, _x6) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee7(url, data) {
        var response;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.next = 3;
                return axios.post(url, data, this._addClientParams());

              case 3:
                response = _context7.sent;
                return _context7.abrupt("return", this.handleResponse(response));

              case 7:
                _context7.prev = 7;
                _context7.t0 = _context7["catch"](0);

                if (!_context7.t0.response) {
                  _context7.next = 13;
                  break;
                }

                return _context7.abrupt("return", this.handleResponse(_context7.t0.response));

              case 13:
                throw _context7.t0;

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 7]]);
      }));

      function post(_x7, _x8) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "patch",
    value: function () {
      var _patch = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee8(url, data) {
        var response;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return axios.patch(url, data, this._addClientParams());

              case 3:
                response = _context8.sent;
                return _context8.abrupt("return", this.handleResponse(response));

              case 7:
                _context8.prev = 7;
                _context8.t0 = _context8["catch"](0);

                if (!_context8.t0.response) {
                  _context8.next = 13;
                  break;
                }

                return _context8.abrupt("return", this.handleResponse(_context8.t0.response));

              case 13:
                throw _context8.t0;

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 7]]);
      }));

      function patch(_x9, _x10) {
        return _patch.apply(this, arguments);
      }

      return patch;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee9(url, params) {
        var response;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return axios.delete(url, this._addClientParams(params));

              case 3:
                response = _context9.sent;
                return _context9.abrupt("return", this.handleResponse(response));

              case 7:
                _context9.prev = 7;
                _context9.t0 = _context9["catch"](0);

                if (!_context9.t0.response) {
                  _context9.next = 13;
                  break;
                }

                return _context9.abrupt("return", this.handleResponse(_context9.t0.response));

              case 13:
                throw _context9.t0;

              case 14:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[0, 7]]);
      }));

      function _delete(_x11, _x12) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "sendFile",
    value: function () {
      var _sendFile = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee10(url, uri, name, contentType, user) {
        var data, fileField, params, response;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                data = new FormData();
                params = this._addClientParams();

                if (isReadableStream(uri)) {
                  fileField = uri;
                } else {
                  fileField = {
                    uri: uri,
                    name: name || uri.split('/').reverse()[0]
                  };

                  if (contentType != null) {
                    fileField.type = contentType;
                  }
                }

                if (user != null) {
                  data.append('user', JSON.stringify(user));
                }

                data.append('file', fileField);
                _context10.next = 7;
                return fetch__default("".concat(url, "?api_key=").concat(this.key), {
                  method: 'post',
                  body: data,
                  headers: new fetch.Headers({
                    Authorization: params.headers.Authorization,
                    'stream-auth-type': this.getAuthType()
                  })
                });

              case 7:
                response = _context10.sent;
                _context10.next = 10;
                return response.json();

              case 10:
                response.data = _context10.sent;
                return _context10.abrupt("return", this.handleResponse(response));

              case 12:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function sendFile(_x13, _x14, _x15, _x16, _x17) {
        return _sendFile.apply(this, arguments);
      }

      return sendFile;
    }()
  }, {
    key: "errorFromResponse",
    value: function errorFromResponse(response) {
      var err;
      err = new Error("StreamChat error HTTP code: ".concat(response.status));

      if (response.data && response.data.code) {
        err = new Error("StreamChat error code ".concat(response.data.code, ": ").concat(response.data.message));
        err.code = response.data.code;
      }

      err.response = response;
      err.status = response.status;
      return err;
    }
  }, {
    key: "handleResponse",
    value: function handleResponse(response) {
      var data = response.data;

      if ((response.status + '')[0] !== '2') {
        throw this.errorFromResponse(response);
      }

      return data;
    }
  }, {
    key: "_handleClientEvent",
    value: function _handleClientEvent(event) {
      var client = this; // update the client.state with any changes to users

      if (event.type === 'user.presence.changed' || event.type === 'user.updated') {
        client.state.updateUser(event.user);
      }

      if (event.type === 'health.check') {
        if (event.me) {
          client.user = event.me;
          client.state.updateUser(event.me);
        }
      }

      if (event.type === 'notification.message_new') {
        this.configs[event.channel.type] = event.channel.config;
      } // gather and call the listeners


      var listeners = [];

      if (client.listeners.all) {
        listeners.push.apply(listeners, _toConsumableArray(client.listeners.all));
      }

      if (client.listeners[event.type]) {
        listeners.push.apply(listeners, _toConsumableArray(client.listeners[event.type]));
      } // call the event and send it to the listeners


      for (var _i2 = 0; _i2 < listeners.length; _i2++) {
        var listener = listeners[_i2];
        listener(event);
      }
    }
  }, {
    key: "connect",
    value: function connect() {
      this.connecting = true;
      var client = this;
      this.failures = 0;

      if (client.userID == null) {
        throw Error('Call setUser or setAnonymousUser before starting the connection');
      }

      var params = {
        client_id: client.clientID,
        user_id: client.userID,
        user_details: client._user,
        user_token: client.userToken
      };
      var qs = encodeURIComponent(JSON.stringify(params));

      if (qs.length > 1900) {
        throw Error('User object is too large');
      }

      var token = '';

      if (this.anonymous === false) {
        token = this.userToken !== null ? this.userToken : JWTServerToken(this.secret);
      }

      var authType = this.getAuthType();
      client.wsURL = "".concat(client.wsBaseURL, "/connect?json=").concat(qs, "&api_key=").concat(this.key, "&authorization=").concat(token, "&stream-auth-type=").concat(authType); // The StableWSConnection handles all the reconnection logic.

      this.wsConnection = new StableWSConnection({
        wsURL: client.wsURL,
        clientID: this.clientID,
        userID: this.userID,
        recoverCallback: this.recoverState,
        messageCallback: this.handleEvent,
        eventCallback: this.dispatchEvent
      });
      this.wsPromise = this.wsConnection.connect();
      return this.wsPromise;
    }
    /**
     * queryUsers - Query users and watch user presence
     *
     * @param {object} filterConditions MongoDB style filter conditions
     * @param {object} sort             Sort options, for instance {last_active: -1}
     * @param {object} options          Option object, {presence: true}
     *
     * @return {object} User Query Response
     */

  }, {
    key: "queryUsers",
    value: function () {
      var _queryUsers = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee11(filterConditions, sort, options) {
        var sortFields, _arr2, _i3, _arr2$_i, k, v, defaultOptions, data;

        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!sort) {
                  sort = {};
                }

                if (!options) {
                  options = {};
                }

                sortFields = [];
                _arr2 = Object.entries(sort);

                for (_i3 = 0; _i3 < _arr2.length; _i3++) {
                  _arr2$_i = _slicedToArray(_arr2[_i3], 2), k = _arr2$_i[0], v = _arr2$_i[1];
                  sortFields.push({
                    field: k,
                    direction: v
                  });
                }

                defaultOptions = {
                  presence: true
                };

                if (!this._hasClientID()) {
                  defaultOptions.presence = false;
                } // Make sure we wait for the connect promise if there is a pending one


                _context11.next = 9;
                return Promise.resolve(this.wsPromise);

              case 9:
                _context11.next = 11;
                return this.get(this.baseURL + '/users', {
                  payload: _objectSpread({
                    filter_conditions: filterConditions,
                    sort: sortFields
                  }, defaultOptions, options)
                });

              case 11:
                data = _context11.sent;
                return _context11.abrupt("return", data);

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function queryUsers(_x18, _x19, _x20) {
        return _queryUsers.apply(this, arguments);
      }

      return queryUsers;
    }()
  }, {
    key: "queryChannels",
    value: function () {
      var _queryChannels = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee12(filterConditions) {
        var sort,
            options,
            sortFields,
            _arr3,
            _i4,
            _arr3$_i,
            k,
            v,
            defaultOptions,
            payload,
            data,
            channels,
            _iteratorNormalCompletion,
            _didIteratorError,
            _iteratorError,
            _iterator,
            _step,
            channelState,
            _iteratorNormalCompletion2,
            _didIteratorError2,
            _iteratorError2,
            _iterator2,
            _step2,
            _channelState,
            c,
            _args12 = arguments;

        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                sort = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};
                options = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {};
                sortFields = [];
                _arr3 = Object.entries(sort);

                for (_i4 = 0; _i4 < _arr3.length; _i4++) {
                  _arr3$_i = _slicedToArray(_arr3[_i4], 2), k = _arr3$_i[0], v = _arr3$_i[1];
                  sortFields.push({
                    field: k,
                    direction: v
                  });
                }

                defaultOptions = {
                  state: true,
                  watch: true,
                  presence: false
                };

                if (!this._hasClientID()) {
                  defaultOptions.watch = false;
                } // Return a list of channels


                payload = _objectSpread({
                  filter_conditions: filterConditions,
                  sort: sortFields,
                  user_details: this._user
                }, defaultOptions, options); // Make sure we wait for the connect promise if there is a pending one

                _context12.next = 10;
                return Promise.resolve(this.wsPromise);

              case 10:
                _context12.next = 12;
                return this.get(this.baseURL + '/channels', {
                  payload: payload
                });

              case 12:
                data = _context12.sent;
                channels = []; // update our cache of the configs

                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context12.prev = 17;

                for (_iterator = data.channels[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  channelState = _step.value;

                  this._addChannelConfig(channelState);
                }

                _context12.next = 25;
                break;

              case 21:
                _context12.prev = 21;
                _context12.t0 = _context12["catch"](17);
                _didIteratorError = true;
                _iteratorError = _context12.t0;

              case 25:
                _context12.prev = 25;
                _context12.prev = 26;

                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }

              case 28:
                _context12.prev = 28;

                if (!_didIteratorError) {
                  _context12.next = 31;
                  break;
                }

                throw _iteratorError;

              case 31:
                return _context12.finish(28);

              case 32:
                return _context12.finish(25);

              case 33:
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context12.prev = 36;

                for (_iterator2 = data.channels[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  _channelState = _step2.value;
                  c = this.channel(_channelState.channel.type, _channelState.channel.id);
                  c.data = _channelState.channel;
                  c.initialized = true;

                  c._initializeState(_channelState);

                  channels.push(c);
                }

                _context12.next = 44;
                break;

              case 40:
                _context12.prev = 40;
                _context12.t1 = _context12["catch"](36);
                _didIteratorError2 = true;
                _iteratorError2 = _context12.t1;

              case 44:
                _context12.prev = 44;
                _context12.prev = 45;

                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }

              case 47:
                _context12.prev = 47;

                if (!_didIteratorError2) {
                  _context12.next = 50;
                  break;
                }

                throw _iteratorError2;

              case 50:
                return _context12.finish(47);

              case 51:
                return _context12.finish(44);

              case 52:
                return _context12.abrupt("return", channels);

              case 53:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[17, 21, 25, 33], [26,, 28, 32], [36, 40, 44, 52], [45,, 47, 51]]);
      }));

      function queryChannels(_x21) {
        return _queryChannels.apply(this, arguments);
      }

      return queryChannels;
    }()
  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee13(filterConditions, query) {
        var options,
            payload,
            data,
            _args13 = arguments;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                options = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : {};
                // Return a list of channels
                payload = _objectSpread({
                  filter_conditions: filterConditions,
                  query: query
                }, options); // Make sure we wait for the connect promise if there is a pending one

                _context13.next = 4;
                return Promise.resolve(this.wsPromise);

              case 4:
                _context13.next = 6;
                return this.get(this.baseURL + '/search', {
                  payload: payload
                });

              case 6:
                data = _context13.sent;
                return _context13.abrupt("return", data);

              case 8:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function search(_x22, _x23) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
    /**
     * addDevice - Adds a push device for a user.
     *
     * @param {string} id the device id
     * @param {string} push_provider the push provider (apn or firebase)
     * @param {string} [userID] the user id (defaults to current user)
     *
     */

  }, {
    key: "addDevice",
    value: function () {
      var _addDevice = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee14(id, push_provider) {
        var userID,
            _args14 = arguments;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                userID = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : null;
                _context14.next = 3;
                return this.post(this.baseURL + '/devices', _objectSpread({
                  id: id,
                  push_provider: push_provider
                }, userID != null ? {
                  user_id: userID
                } : {}));

              case 3:
                return _context14.abrupt("return", _context14.sent);

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function addDevice(_x24, _x25) {
        return _addDevice.apply(this, arguments);
      }

      return addDevice;
    }()
    /**
     * getDevices - Returns the devices associated with a current user
     *
     * @param {string} [userID] User ID. Only works on serversidex
     *
     * @return {devices} Array of devices
     */

  }, {
    key: "getDevices",
    value: function () {
      var _getDevices = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee15(userID) {
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.get(this.baseURL + '/devices', userID ? {
                  user_id: userID
                } : {});

              case 2:
                return _context15.abrupt("return", _context15.sent);

              case 3:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getDevices(_x26) {
        return _getDevices.apply(this, arguments);
      }

      return getDevices;
    }()
    /**
     * removeDevice - Removes the device with the given id. Clientside users can only delete their own devices
     *
     * @param {string} id The device id
     * @param {string} [userID] The user id. Only specify this for serverside requests
     *
     */

  }, {
    key: "removeDevice",
    value: function () {
      var _removeDevice = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee16(id) {
        var userID,
            _args16 = arguments;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                userID = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : null;
                _context16.next = 3;
                return this.delete(this.baseURL + '/devices', _objectSpread({
                  id: id
                }, userID ? {
                  user_id: userID
                } : {}));

              case 3:
                return _context16.abrupt("return", _context16.sent);

              case 4:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function removeDevice(_x27) {
        return _removeDevice.apply(this, arguments);
      }

      return removeDevice;
    }()
  }, {
    key: "_addChannelConfig",
    value: function _addChannelConfig(channelState) {
      this.configs[channelState.channel.type] = channelState.channel.config;
    }
    /**
     * channel - Returns a new channel with the given type and id
     *
     * @param {string} channelType The channel type
     * @param {string} channelID   The channel data
     * @param {object} [custom]      Custom data to attach to the channel
     *
     * @return {channel} The channel object, initialize it using channel.watch()
     */

  }, {
    key: "channel",
    value: function channel(channelType, channelID) {
      var custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!this.userID && !this._isUsingServerAuth()) {
        throw Error('Call setUser or setAnonymousUser before creating a channel');
      }

      if (~channelType.indexOf(':')) {
        throw Error("Invalid channel group ".concat(channelType, ", cant contain the : character"));
      }

      if (typeof channelID === 'string') {
        channelID = channelID + '';

        if (~channelID.indexOf(':')) {
          throw Error("Invalid channel id ".concat(channelID, ", cant contain the : character"));
        }
      } else {
        // support the 2 param init method
        custom = channelID || {};
        channelID = undefined;
      } // there are two ways of solving this,
      // a. only allow 1 channel object per cid
      // b. broadcast events to all channels
      // the first option seems less likely to trip up devs


      var channel;

      if (channelID) {
        var cid = "".concat(channelType, ":").concat(channelID);

        if (cid in this.activeChannels) {
          channel = this.activeChannels[cid];

          if (Object.keys(custom).length > 0) {
            channel.data = custom;
            channel._data = custom;
          }
        } else {
          channel = new Channel(this, channelType, channelID, custom);
          this.activeChannels[channel.cid] = channel;
        }
      } else {
        channel = new Channel(this, channelType, undefined, custom);
      }

      return channel;
    }
    /**
     * updateUser - Update or Create the given user object
     *
     * @param {object} A user object, the only required field is the user id. IE {id: "myuser"} is valid
     *
     * @return {object}
     */

  }, {
    key: "updateUser",
    value: function () {
      var _updateUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee17(userObject) {
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.updateUsers([userObject]);

              case 2:
                return _context17.abrupt("return", _context17.sent);

              case 3:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function updateUser(_x28) {
        return _updateUser.apply(this, arguments);
      }

      return updateUser;
    }()
    /**
     * updateUsers - Batch update the list of users
     *
     * @param {array} A list of users
     *
     * @return {object}
     */

  }, {
    key: "updateUsers",
    value: function () {
      var _updateUsers = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee18(users) {
        var userMap, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, userObject;

        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                userMap = {};
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context18.prev = 4;
                _iterator3 = users[Symbol.iterator]();

              case 6:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                  _context18.next = 14;
                  break;
                }

                userObject = _step3.value;

                if (userObject.id) {
                  _context18.next = 10;
                  break;
                }

                throw Error('User ID is required when updating a user');

              case 10:
                userMap[userObject.id] = userObject;

              case 11:
                _iteratorNormalCompletion3 = true;
                _context18.next = 6;
                break;

              case 14:
                _context18.next = 20;
                break;

              case 16:
                _context18.prev = 16;
                _context18.t0 = _context18["catch"](4);
                _didIteratorError3 = true;
                _iteratorError3 = _context18.t0;

              case 20:
                _context18.prev = 20;
                _context18.prev = 21;

                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }

              case 23:
                _context18.prev = 23;

                if (!_didIteratorError3) {
                  _context18.next = 26;
                  break;
                }

                throw _iteratorError3;

              case 26:
                return _context18.finish(23);

              case 27:
                return _context18.finish(20);

              case 28:
                _context18.next = 30;
                return this.post(this.baseURL + '/users', {
                  users: userMap
                });

              case 30:
                return _context18.abrupt("return", _context18.sent);

              case 31:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[4, 16, 20, 28], [21,, 23, 27]]);
      }));

      function updateUsers(_x29) {
        return _updateUsers.apply(this, arguments);
      }

      return updateUsers;
    }()
    /** banUser - bans a user from all channels
     *
     * @param targetUserID
     * @param options
     * @returns {Promise<*>}
     */

  }, {
    key: "banUser",
    value: function () {
      var _banUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee19(targetUserID, options) {
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.post(this.baseURL + '/moderation/ban', _objectSpread({
                  target_user_id: targetUserID
                }, options));

              case 2:
                return _context19.abrupt("return", _context19.sent);

              case 3:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function banUser(_x30, _x31) {
        return _banUser.apply(this, arguments);
      }

      return banUser;
    }()
    /** unbanUser - revoke global ban for a user
     *
     * @param targetUserID
     * @returns {Promise<*>}
     */

  }, {
    key: "unbanUser",
    value: function () {
      var _unbanUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee20(targetUserID, options) {
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.delete(this.baseURL + '/moderation/ban', _objectSpread({
                  target_user_id: targetUserID
                }, options));

              case 2:
                return _context20.abrupt("return", _context20.sent);

              case 3:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function unbanUser(_x32, _x33) {
        return _unbanUser.apply(this, arguments);
      }

      return unbanUser;
    }()
    /** muteUser - mutes a user
     *
     * @param targetID
     * @param [userID] Only used with serverside auth
     * @returns {Promise<*>}
     */

  }, {
    key: "muteUser",
    value: function () {
      var _muteUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee21(targetID) {
        var userID,
            _args21 = arguments;
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                userID = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : null;
                _context21.next = 3;
                return this.post(this.baseURL + '/moderation/mute', _objectSpread({
                  target_id: targetID
                }, userID ? {
                  user_id: userID
                } : {}));

              case 3:
                return _context21.abrupt("return", _context21.sent);

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function muteUser(_x34) {
        return _muteUser.apply(this, arguments);
      }

      return muteUser;
    }()
    /** unmuteUser - unmutes a user
     *
     * @param targetID
     * @param [userID] Only used with serverside auth
     * @returns {Promise<*>}
     */

  }, {
    key: "unmuteUser",
    value: function () {
      var _unmuteUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee22(targetID) {
        var userID,
            _args22 = arguments;
        return _regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                userID = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : null;
                _context22.next = 3;
                return this.post(this.baseURL + '/moderation/unmute', _objectSpread({
                  target_id: targetID
                }, userID ? {
                  user_id: userID
                } : {}));

              case 3:
                return _context22.abrupt("return", _context22.sent);

              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function unmuteUser(_x35) {
        return _unmuteUser.apply(this, arguments);
      }

      return unmuteUser;
    }()
  }, {
    key: "flagMessage",
    value: function () {
      var _flagMessage = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee23(messageID) {
        return _regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.post(this.baseURL + '/moderation/flag', {
                  target_message_id: messageID
                });

              case 2:
                return _context23.abrupt("return", _context23.sent);

              case 3:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function flagMessage(_x36) {
        return _flagMessage.apply(this, arguments);
      }

      return flagMessage;
    }()
  }, {
    key: "flagUser",
    value: function () {
      var _flagUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee24(userID) {
        return _regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.post(this.baseURL + '/moderation/flag', {
                  target_user_id: userID
                });

              case 2:
                return _context24.abrupt("return", _context24.sent);

              case 3:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function flagUser(_x37) {
        return _flagUser.apply(this, arguments);
      }

      return flagUser;
    }()
  }, {
    key: "unflagMessage",
    value: function () {
      var _unflagMessage = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee25(messageID) {
        return _regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.post(this.baseURL + '/moderation/unflag', {
                  target_message_id: messageID
                });

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function unflagMessage(_x38) {
        return _unflagMessage.apply(this, arguments);
      }

      return unflagMessage;
    }()
  }, {
    key: "unflagUser",
    value: function () {
      var _unflagUser = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee26(userID) {
        return _regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.post(this.baseURL + '/moderation/unflag', {
                  target_user_id: userID
                });

              case 2:
                return _context26.abrupt("return", _context26.sent);

              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function unflagUser(_x39) {
        return _unflagUser.apply(this, arguments);
      }

      return unflagUser;
    }()
  }, {
    key: "createChannelType",
    value: function createChannelType(data) {
      var channelData = _extends({}, {
        commands: ['all']
      }, data);

      return this.post(this.baseURL + '/channeltypes', channelData);
    }
  }, {
    key: "getChannelType",
    value: function getChannelType(channelType) {
      return this.get(this.baseURL + "/channeltypes/".concat(channelType));
    }
  }, {
    key: "updateChannelType",
    value: function updateChannelType(channelType, data) {
      return this.put(this.baseURL + "/channeltypes/".concat(channelType), data);
    }
  }, {
    key: "deleteChannelType",
    value: function deleteChannelType(channelType) {
      return this.delete(this.baseURL + "/channeltypes/".concat(channelType));
    }
  }, {
    key: "listChannelTypes",
    value: function listChannelTypes() {
      return this.get(this.baseURL + "/channeltypes");
    }
    /**
     * updateMessage - Update the given message
     *
     * @param {object} message object, id needs to be specified
     *
     * @return {object} Response that includes the message
     */

  }, {
    key: "updateMessage",
    value: function () {
      var _updateMessage = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee27(message, userId) {
        var clonedMessage, reservedMessageFields;
        return _regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (message.id) {
                  _context27.next = 2;
                  break;
                }

                throw Error('Please specify the message id when calling updateMesssage');

              case 2:
                clonedMessage = _extends({}, message);
                delete clonedMessage.id;
                reservedMessageFields = ['latest_reactions', 'own_reactions', 'reply_count', 'created_at', 'updated_at', 'html', 'command', 'type', 'user'];
                reservedMessageFields.forEach(function (item) {
                  if (clonedMessage[item] != null) {
                    delete clonedMessage[item];
                  }
                });

                if (userId != null) {
                  clonedMessage.user = {
                    id: userId
                  };
                }

                _context27.next = 9;
                return this.post(this.baseURL + "/messages/".concat(message.id), {
                  message: clonedMessage
                });

              case 9:
                return _context27.abrupt("return", _context27.sent);

              case 10:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function updateMessage(_x40, _x41) {
        return _updateMessage.apply(this, arguments);
      }

      return updateMessage;
    }()
  }, {
    key: "deleteMessage",
    value: function () {
      var _deleteMessage = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee28(messageID) {
        return _regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.delete(this.baseURL + "/messages/".concat(messageID));

              case 2:
                return _context28.abrupt("return", _context28.sent);

              case 3:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function deleteMessage(_x42) {
        return _deleteMessage.apply(this, arguments);
      }

      return deleteMessage;
    }()
  }, {
    key: "_userAgent",
    value: function _userAgent() {
      var description = this.node ? 'node' : 'browser';
      var version = '1.0';
      return "stream-chat-".concat(description, "-").concat(version);
    }
    /**
     * _isUsingServerAuth - Returns true if we're using server side auth
     */

  }, {
    key: "_addClientParams",
    value: function _addClientParams() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var token = '';

      if (this.secret === null && this.userToken === null && this.anonymous === false) {
        throw new Error('Both secret and user tokens are not set, did you forget to call client.setUser?');
      }

      if (this.anonymous === false) {
        token = this.userToken !== null ? this.userToken : JWTServerToken(this.secret);
      }

      return _objectSpread({}, this.options, {
        params: _objectSpread({
          user_id: this.userID
        }, params, {
          api_key: this.key,
          client_id: this.clientID
        }),
        headers: {
          Authorization: token,
          'stream-auth-type': this.getAuthType()
        }
      });
    }
  }, {
    key: "_startCleaning",
    value: function _startCleaning() {
      var that = this;
      this.cleaningIntervalRef = setInterval(function () {
        // call clean on the channel, used for calling the stop.typing event etc.
        var _arr4 = Object.values(that.activeChannels);

        for (var _i5 = 0; _i5 < _arr4.length; _i5++) {
          var channel = _arr4[_i5];
          channel.clean();
        }
      }, 500);
    }
  }, {
    key: "verifyWebhook",
    value: function verifyWebhook(requestBody, xSignature) {
      return CheckSignature(requestBody, this.secret, xSignature);
    }
  }]);

  return StreamChat;
}();

exports.StreamChat = StreamChat;
exports.logChatPromiseExecution = logChatPromiseExecution;
//# sourceMappingURL=browser.js.map
